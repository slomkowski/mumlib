// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Mumble.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Mumble_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Mumble_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Mumble_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Mumble_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[32]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Mumble_2eproto;
namespace MumbleProto {
class ACL;
class ACLDefaultTypeInternal;
extern ACLDefaultTypeInternal _ACL_default_instance_;
class ACL_ChanACL;
class ACL_ChanACLDefaultTypeInternal;
extern ACL_ChanACLDefaultTypeInternal _ACL_ChanACL_default_instance_;
class ACL_ChanGroup;
class ACL_ChanGroupDefaultTypeInternal;
extern ACL_ChanGroupDefaultTypeInternal _ACL_ChanGroup_default_instance_;
class Authenticate;
class AuthenticateDefaultTypeInternal;
extern AuthenticateDefaultTypeInternal _Authenticate_default_instance_;
class BanList;
class BanListDefaultTypeInternal;
extern BanListDefaultTypeInternal _BanList_default_instance_;
class BanList_BanEntry;
class BanList_BanEntryDefaultTypeInternal;
extern BanList_BanEntryDefaultTypeInternal _BanList_BanEntry_default_instance_;
class ChannelRemove;
class ChannelRemoveDefaultTypeInternal;
extern ChannelRemoveDefaultTypeInternal _ChannelRemove_default_instance_;
class ChannelState;
class ChannelStateDefaultTypeInternal;
extern ChannelStateDefaultTypeInternal _ChannelState_default_instance_;
class CodecVersion;
class CodecVersionDefaultTypeInternal;
extern CodecVersionDefaultTypeInternal _CodecVersion_default_instance_;
class ContextAction;
class ContextActionDefaultTypeInternal;
extern ContextActionDefaultTypeInternal _ContextAction_default_instance_;
class ContextActionModify;
class ContextActionModifyDefaultTypeInternal;
extern ContextActionModifyDefaultTypeInternal _ContextActionModify_default_instance_;
class CryptSetup;
class CryptSetupDefaultTypeInternal;
extern CryptSetupDefaultTypeInternal _CryptSetup_default_instance_;
class PermissionDenied;
class PermissionDeniedDefaultTypeInternal;
extern PermissionDeniedDefaultTypeInternal _PermissionDenied_default_instance_;
class PermissionQuery;
class PermissionQueryDefaultTypeInternal;
extern PermissionQueryDefaultTypeInternal _PermissionQuery_default_instance_;
class Ping;
class PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class QueryUsers;
class QueryUsersDefaultTypeInternal;
extern QueryUsersDefaultTypeInternal _QueryUsers_default_instance_;
class Reject;
class RejectDefaultTypeInternal;
extern RejectDefaultTypeInternal _Reject_default_instance_;
class RequestBlob;
class RequestBlobDefaultTypeInternal;
extern RequestBlobDefaultTypeInternal _RequestBlob_default_instance_;
class ServerConfig;
class ServerConfigDefaultTypeInternal;
extern ServerConfigDefaultTypeInternal _ServerConfig_default_instance_;
class ServerSync;
class ServerSyncDefaultTypeInternal;
extern ServerSyncDefaultTypeInternal _ServerSync_default_instance_;
class SuggestConfig;
class SuggestConfigDefaultTypeInternal;
extern SuggestConfigDefaultTypeInternal _SuggestConfig_default_instance_;
class TextMessage;
class TextMessageDefaultTypeInternal;
extern TextMessageDefaultTypeInternal _TextMessage_default_instance_;
class UDPTunnel;
class UDPTunnelDefaultTypeInternal;
extern UDPTunnelDefaultTypeInternal _UDPTunnel_default_instance_;
class UserList;
class UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
class UserList_User;
class UserList_UserDefaultTypeInternal;
extern UserList_UserDefaultTypeInternal _UserList_User_default_instance_;
class UserRemove;
class UserRemoveDefaultTypeInternal;
extern UserRemoveDefaultTypeInternal _UserRemove_default_instance_;
class UserState;
class UserStateDefaultTypeInternal;
extern UserStateDefaultTypeInternal _UserState_default_instance_;
class UserStats;
class UserStatsDefaultTypeInternal;
extern UserStatsDefaultTypeInternal _UserStats_default_instance_;
class UserStats_Stats;
class UserStats_StatsDefaultTypeInternal;
extern UserStats_StatsDefaultTypeInternal _UserStats_Stats_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
class VoiceTarget;
class VoiceTargetDefaultTypeInternal;
extern VoiceTargetDefaultTypeInternal _VoiceTarget_default_instance_;
class VoiceTarget_Target;
class VoiceTarget_TargetDefaultTypeInternal;
extern VoiceTarget_TargetDefaultTypeInternal _VoiceTarget_Target_default_instance_;
}  // namespace MumbleProto
PROTOBUF_NAMESPACE_OPEN
template<> ::MumbleProto::ACL* Arena::CreateMaybeMessage<::MumbleProto::ACL>(Arena*);
template<> ::MumbleProto::ACL_ChanACL* Arena::CreateMaybeMessage<::MumbleProto::ACL_ChanACL>(Arena*);
template<> ::MumbleProto::ACL_ChanGroup* Arena::CreateMaybeMessage<::MumbleProto::ACL_ChanGroup>(Arena*);
template<> ::MumbleProto::Authenticate* Arena::CreateMaybeMessage<::MumbleProto::Authenticate>(Arena*);
template<> ::MumbleProto::BanList* Arena::CreateMaybeMessage<::MumbleProto::BanList>(Arena*);
template<> ::MumbleProto::BanList_BanEntry* Arena::CreateMaybeMessage<::MumbleProto::BanList_BanEntry>(Arena*);
template<> ::MumbleProto::ChannelRemove* Arena::CreateMaybeMessage<::MumbleProto::ChannelRemove>(Arena*);
template<> ::MumbleProto::ChannelState* Arena::CreateMaybeMessage<::MumbleProto::ChannelState>(Arena*);
template<> ::MumbleProto::CodecVersion* Arena::CreateMaybeMessage<::MumbleProto::CodecVersion>(Arena*);
template<> ::MumbleProto::ContextAction* Arena::CreateMaybeMessage<::MumbleProto::ContextAction>(Arena*);
template<> ::MumbleProto::ContextActionModify* Arena::CreateMaybeMessage<::MumbleProto::ContextActionModify>(Arena*);
template<> ::MumbleProto::CryptSetup* Arena::CreateMaybeMessage<::MumbleProto::CryptSetup>(Arena*);
template<> ::MumbleProto::PermissionDenied* Arena::CreateMaybeMessage<::MumbleProto::PermissionDenied>(Arena*);
template<> ::MumbleProto::PermissionQuery* Arena::CreateMaybeMessage<::MumbleProto::PermissionQuery>(Arena*);
template<> ::MumbleProto::Ping* Arena::CreateMaybeMessage<::MumbleProto::Ping>(Arena*);
template<> ::MumbleProto::QueryUsers* Arena::CreateMaybeMessage<::MumbleProto::QueryUsers>(Arena*);
template<> ::MumbleProto::Reject* Arena::CreateMaybeMessage<::MumbleProto::Reject>(Arena*);
template<> ::MumbleProto::RequestBlob* Arena::CreateMaybeMessage<::MumbleProto::RequestBlob>(Arena*);
template<> ::MumbleProto::ServerConfig* Arena::CreateMaybeMessage<::MumbleProto::ServerConfig>(Arena*);
template<> ::MumbleProto::ServerSync* Arena::CreateMaybeMessage<::MumbleProto::ServerSync>(Arena*);
template<> ::MumbleProto::SuggestConfig* Arena::CreateMaybeMessage<::MumbleProto::SuggestConfig>(Arena*);
template<> ::MumbleProto::TextMessage* Arena::CreateMaybeMessage<::MumbleProto::TextMessage>(Arena*);
template<> ::MumbleProto::UDPTunnel* Arena::CreateMaybeMessage<::MumbleProto::UDPTunnel>(Arena*);
template<> ::MumbleProto::UserList* Arena::CreateMaybeMessage<::MumbleProto::UserList>(Arena*);
template<> ::MumbleProto::UserList_User* Arena::CreateMaybeMessage<::MumbleProto::UserList_User>(Arena*);
template<> ::MumbleProto::UserRemove* Arena::CreateMaybeMessage<::MumbleProto::UserRemove>(Arena*);
template<> ::MumbleProto::UserState* Arena::CreateMaybeMessage<::MumbleProto::UserState>(Arena*);
template<> ::MumbleProto::UserStats* Arena::CreateMaybeMessage<::MumbleProto::UserStats>(Arena*);
template<> ::MumbleProto::UserStats_Stats* Arena::CreateMaybeMessage<::MumbleProto::UserStats_Stats>(Arena*);
template<> ::MumbleProto::Version* Arena::CreateMaybeMessage<::MumbleProto::Version>(Arena*);
template<> ::MumbleProto::VoiceTarget* Arena::CreateMaybeMessage<::MumbleProto::VoiceTarget>(Arena*);
template<> ::MumbleProto::VoiceTarget_Target* Arena::CreateMaybeMessage<::MumbleProto::VoiceTarget_Target>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace MumbleProto {

enum Reject_RejectType : int {
  Reject_RejectType_None = 0,
  Reject_RejectType_WrongVersion = 1,
  Reject_RejectType_InvalidUsername = 2,
  Reject_RejectType_WrongUserPW = 3,
  Reject_RejectType_WrongServerPW = 4,
  Reject_RejectType_UsernameInUse = 5,
  Reject_RejectType_ServerFull = 6,
  Reject_RejectType_NoCertificate = 7,
  Reject_RejectType_AuthenticatorFail = 8
};
bool Reject_RejectType_IsValid(int value);
constexpr Reject_RejectType Reject_RejectType_RejectType_MIN = Reject_RejectType_None;
constexpr Reject_RejectType Reject_RejectType_RejectType_MAX = Reject_RejectType_AuthenticatorFail;
constexpr int Reject_RejectType_RejectType_ARRAYSIZE = Reject_RejectType_RejectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Reject_RejectType_descriptor();
template<typename T>
inline const std::string& Reject_RejectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Reject_RejectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Reject_RejectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Reject_RejectType_descriptor(), enum_t_value);
}
inline bool Reject_RejectType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Reject_RejectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Reject_RejectType>(
    Reject_RejectType_descriptor(), name, value);
}
enum PermissionDenied_DenyType : int {
  PermissionDenied_DenyType_Text = 0,
  PermissionDenied_DenyType_Permission = 1,
  PermissionDenied_DenyType_SuperUser = 2,
  PermissionDenied_DenyType_ChannelName = 3,
  PermissionDenied_DenyType_TextTooLong = 4,
  PermissionDenied_DenyType_H9K = 5,
  PermissionDenied_DenyType_TemporaryChannel = 6,
  PermissionDenied_DenyType_MissingCertificate = 7,
  PermissionDenied_DenyType_UserName = 8,
  PermissionDenied_DenyType_ChannelFull = 9,
  PermissionDenied_DenyType_NestingLimit = 10
};
bool PermissionDenied_DenyType_IsValid(int value);
constexpr PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MIN = PermissionDenied_DenyType_Text;
constexpr PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MAX = PermissionDenied_DenyType_NestingLimit;
constexpr int PermissionDenied_DenyType_DenyType_ARRAYSIZE = PermissionDenied_DenyType_DenyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PermissionDenied_DenyType_descriptor();
template<typename T>
inline const std::string& PermissionDenied_DenyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PermissionDenied_DenyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PermissionDenied_DenyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PermissionDenied_DenyType_descriptor(), enum_t_value);
}
inline bool PermissionDenied_DenyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PermissionDenied_DenyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PermissionDenied_DenyType>(
    PermissionDenied_DenyType_descriptor(), name, value);
}
enum ContextActionModify_Context : int {
  ContextActionModify_Context_Server = 1,
  ContextActionModify_Context_Channel = 2,
  ContextActionModify_Context_User = 4
};
bool ContextActionModify_Context_IsValid(int value);
constexpr ContextActionModify_Context ContextActionModify_Context_Context_MIN = ContextActionModify_Context_Server;
constexpr ContextActionModify_Context ContextActionModify_Context_Context_MAX = ContextActionModify_Context_User;
constexpr int ContextActionModify_Context_Context_ARRAYSIZE = ContextActionModify_Context_Context_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContextActionModify_Context_descriptor();
template<typename T>
inline const std::string& ContextActionModify_Context_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContextActionModify_Context>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContextActionModify_Context_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContextActionModify_Context_descriptor(), enum_t_value);
}
inline bool ContextActionModify_Context_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContextActionModify_Context* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContextActionModify_Context>(
    ContextActionModify_Context_descriptor(), name, value);
}
enum ContextActionModify_Operation : int {
  ContextActionModify_Operation_Add = 0,
  ContextActionModify_Operation_Remove = 1
};
bool ContextActionModify_Operation_IsValid(int value);
constexpr ContextActionModify_Operation ContextActionModify_Operation_Operation_MIN = ContextActionModify_Operation_Add;
constexpr ContextActionModify_Operation ContextActionModify_Operation_Operation_MAX = ContextActionModify_Operation_Remove;
constexpr int ContextActionModify_Operation_Operation_ARRAYSIZE = ContextActionModify_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContextActionModify_Operation_descriptor();
template<typename T>
inline const std::string& ContextActionModify_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContextActionModify_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContextActionModify_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContextActionModify_Operation_descriptor(), enum_t_value);
}
inline bool ContextActionModify_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContextActionModify_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContextActionModify_Operation>(
    ContextActionModify_Operation_descriptor(), name, value);
}
// ===================================================================

class Version PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.Version) */ {
 public:
  inline Version() : Version(nullptr) {};
  virtual ~Version();

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const final {
    return CreateMaybeMessage<Version>(nullptr);
  }

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReleaseFieldNumber = 2,
    kOsFieldNumber = 3,
    kOsVersionFieldNumber = 4,
    kVersionFieldNumber = 1,
  };
  // optional string release = 2;
  bool has_release() const;
  private:
  bool _internal_has_release() const;
  public:
  void clear_release();
  const std::string& release() const;
  void set_release(const std::string& value);
  void set_release(std::string&& value);
  void set_release(const char* value);
  void set_release(const char* value, size_t size);
  std::string* mutable_release();
  std::string* release_release();
  void set_allocated_release(std::string* release);
  private:
  const std::string& _internal_release() const;
  void _internal_set_release(const std::string& value);
  std::string* _internal_mutable_release();
  public:

  // optional string os = 3;
  bool has_os() const;
  private:
  bool _internal_has_os() const;
  public:
  void clear_os();
  const std::string& os() const;
  void set_os(const std::string& value);
  void set_os(std::string&& value);
  void set_os(const char* value);
  void set_os(const char* value, size_t size);
  std::string* mutable_os();
  std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // optional string os_version = 4;
  bool has_os_version() const;
  private:
  bool _internal_has_os_version() const;
  public:
  void clear_os_version();
  const std::string& os_version() const;
  void set_os_version(const std::string& value);
  void set_os_version(std::string&& value);
  void set_os_version(const char* value);
  void set_os_version(const char* value, size_t size);
  std::string* mutable_os_version();
  std::string* release_os_version();
  void set_allocated_os_version(std::string* os_version);
  private:
  const std::string& _internal_os_version() const;
  void _internal_set_os_version(const std::string& value);
  std::string* _internal_mutable_os_version();
  public:

  // optional uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr release_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UDPTunnel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UDPTunnel) */ {
 public:
  inline UDPTunnel() : UDPTunnel(nullptr) {};
  virtual ~UDPTunnel();

  UDPTunnel(const UDPTunnel& from);
  UDPTunnel(UDPTunnel&& from) noexcept
    : UDPTunnel() {
    *this = ::std::move(from);
  }

  inline UDPTunnel& operator=(const UDPTunnel& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDPTunnel& operator=(UDPTunnel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UDPTunnel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UDPTunnel* internal_default_instance() {
    return reinterpret_cast<const UDPTunnel*>(
               &_UDPTunnel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UDPTunnel& a, UDPTunnel& b) {
    a.Swap(&b);
  }
  inline void Swap(UDPTunnel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDPTunnel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UDPTunnel* New() const final {
    return CreateMaybeMessage<UDPTunnel>(nullptr);
  }

  UDPTunnel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UDPTunnel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UDPTunnel& from);
  void MergeFrom(const UDPTunnel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDPTunnel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.UDPTunnel";
  }
  protected:
  explicit UDPTunnel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketFieldNumber = 1,
  };
  // required bytes packet = 1;
  bool has_packet() const;
  private:
  bool _internal_has_packet() const;
  public:
  void clear_packet();
  const std::string& packet() const;
  void set_packet(const std::string& value);
  void set_packet(std::string&& value);
  void set_packet(const char* value);
  void set_packet(const void* value, size_t size);
  std::string* mutable_packet();
  std::string* release_packet();
  void set_allocated_packet(std::string* packet);
  private:
  const std::string& _internal_packet() const;
  void _internal_set_packet(const std::string& value);
  std::string* _internal_mutable_packet();
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.UDPTunnel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr packet_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class Authenticate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.Authenticate) */ {
 public:
  inline Authenticate() : Authenticate(nullptr) {};
  virtual ~Authenticate();

  Authenticate(const Authenticate& from);
  Authenticate(Authenticate&& from) noexcept
    : Authenticate() {
    *this = ::std::move(from);
  }

  inline Authenticate& operator=(const Authenticate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Authenticate& operator=(Authenticate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Authenticate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticate* internal_default_instance() {
    return reinterpret_cast<const Authenticate*>(
               &_Authenticate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Authenticate& a, Authenticate& b) {
    a.Swap(&b);
  }
  inline void Swap(Authenticate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Authenticate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Authenticate* New() const final {
    return CreateMaybeMessage<Authenticate>(nullptr);
  }

  Authenticate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Authenticate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Authenticate& from);
  void MergeFrom(const Authenticate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.Authenticate";
  }
  protected:
  explicit Authenticate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 3,
    kCeltVersionsFieldNumber = 4,
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kOpusFieldNumber = 5,
  };
  // repeated string tokens = 3;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  const std::string& tokens(int index) const;
  std::string* mutable_tokens(int index);
  void set_tokens(int index, const std::string& value);
  void set_tokens(int index, std::string&& value);
  void set_tokens(int index, const char* value);
  void set_tokens(int index, const char* value, size_t size);
  std::string* add_tokens();
  void add_tokens(const std::string& value);
  void add_tokens(std::string&& value);
  void add_tokens(const char* value);
  void add_tokens(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tokens() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tokens();
  private:
  const std::string& _internal_tokens(int index) const;
  std::string* _internal_add_tokens();
  public:

  // repeated int32 celt_versions = 4;
  int celt_versions_size() const;
  private:
  int _internal_celt_versions_size() const;
  public:
  void clear_celt_versions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_celt_versions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_celt_versions() const;
  void _internal_add_celt_versions(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_celt_versions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 celt_versions(int index) const;
  void set_celt_versions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_celt_versions(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      celt_versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_celt_versions();

  // optional string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional bool opus = 5 [default = false];
  bool has_opus() const;
  private:
  bool _internal_has_opus() const;
  public:
  void clear_opus();
  bool opus() const;
  void set_opus(bool value);
  private:
  bool _internal_opus() const;
  void _internal_set_opus(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.Authenticate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tokens_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > celt_versions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  bool opus_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class Ping PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {};
  virtual ~Ping();

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ping* New() const final {
    return CreateMaybeMessage<Ping>(nullptr);
  }

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kGoodFieldNumber = 2,
    kLateFieldNumber = 3,
    kLostFieldNumber = 4,
    kResyncFieldNumber = 5,
    kUdpPacketsFieldNumber = 6,
    kTcpPacketsFieldNumber = 7,
    kUdpPingAvgFieldNumber = 8,
    kUdpPingVarFieldNumber = 9,
    kTcpPingAvgFieldNumber = 10,
    kTcpPingVarFieldNumber = 11,
  };
  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 good = 2;
  bool has_good() const;
  private:
  bool _internal_has_good() const;
  public:
  void clear_good();
  ::PROTOBUF_NAMESPACE_ID::uint32 good() const;
  void set_good(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_good() const;
  void _internal_set_good(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 late = 3;
  bool has_late() const;
  private:
  bool _internal_has_late() const;
  public:
  void clear_late();
  ::PROTOBUF_NAMESPACE_ID::uint32 late() const;
  void set_late(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_late() const;
  void _internal_set_late(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 lost = 4;
  bool has_lost() const;
  private:
  bool _internal_has_lost() const;
  public:
  void clear_lost();
  ::PROTOBUF_NAMESPACE_ID::uint32 lost() const;
  void set_lost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lost() const;
  void _internal_set_lost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 resync = 5;
  bool has_resync() const;
  private:
  bool _internal_has_resync() const;
  public:
  void clear_resync();
  ::PROTOBUF_NAMESPACE_ID::uint32 resync() const;
  void set_resync(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_resync() const;
  void _internal_set_resync(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 udp_packets = 6;
  bool has_udp_packets() const;
  private:
  bool _internal_has_udp_packets() const;
  public:
  void clear_udp_packets();
  ::PROTOBUF_NAMESPACE_ID::uint32 udp_packets() const;
  void set_udp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_udp_packets() const;
  void _internal_set_udp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 tcp_packets = 7;
  bool has_tcp_packets() const;
  private:
  bool _internal_has_tcp_packets() const;
  public:
  void clear_tcp_packets();
  ::PROTOBUF_NAMESPACE_ID::uint32 tcp_packets() const;
  void set_tcp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tcp_packets() const;
  void _internal_set_tcp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float udp_ping_avg = 8;
  bool has_udp_ping_avg() const;
  private:
  bool _internal_has_udp_ping_avg() const;
  public:
  void clear_udp_ping_avg();
  float udp_ping_avg() const;
  void set_udp_ping_avg(float value);
  private:
  float _internal_udp_ping_avg() const;
  void _internal_set_udp_ping_avg(float value);
  public:

  // optional float udp_ping_var = 9;
  bool has_udp_ping_var() const;
  private:
  bool _internal_has_udp_ping_var() const;
  public:
  void clear_udp_ping_var();
  float udp_ping_var() const;
  void set_udp_ping_var(float value);
  private:
  float _internal_udp_ping_var() const;
  void _internal_set_udp_ping_var(float value);
  public:

  // optional float tcp_ping_avg = 10;
  bool has_tcp_ping_avg() const;
  private:
  bool _internal_has_tcp_ping_avg() const;
  public:
  void clear_tcp_ping_avg();
  float tcp_ping_avg() const;
  void set_tcp_ping_avg(float value);
  private:
  float _internal_tcp_ping_avg() const;
  void _internal_set_tcp_ping_avg(float value);
  public:

  // optional float tcp_ping_var = 11;
  bool has_tcp_ping_var() const;
  private:
  bool _internal_has_tcp_ping_var() const;
  public:
  void clear_tcp_ping_var();
  float tcp_ping_var() const;
  void set_tcp_ping_var(float value);
  private:
  float _internal_tcp_ping_var() const;
  void _internal_set_tcp_ping_var(float value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 good_;
  ::PROTOBUF_NAMESPACE_ID::uint32 late_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lost_;
  ::PROTOBUF_NAMESPACE_ID::uint32 resync_;
  ::PROTOBUF_NAMESPACE_ID::uint32 udp_packets_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tcp_packets_;
  float udp_ping_avg_;
  float udp_ping_var_;
  float tcp_ping_avg_;
  float tcp_ping_var_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class Reject PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.Reject) */ {
 public:
  inline Reject() : Reject(nullptr) {};
  virtual ~Reject();

  Reject(const Reject& from);
  Reject(Reject&& from) noexcept
    : Reject() {
    *this = ::std::move(from);
  }

  inline Reject& operator=(const Reject& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reject& operator=(Reject&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Reject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reject* internal_default_instance() {
    return reinterpret_cast<const Reject*>(
               &_Reject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Reject& a, Reject& b) {
    a.Swap(&b);
  }
  inline void Swap(Reject* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Reject* New() const final {
    return CreateMaybeMessage<Reject>(nullptr);
  }

  Reject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Reject& from);
  void MergeFrom(const Reject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.Reject";
  }
  protected:
  explicit Reject(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Reject_RejectType RejectType;
  static constexpr RejectType None =
    Reject_RejectType_None;
  static constexpr RejectType WrongVersion =
    Reject_RejectType_WrongVersion;
  static constexpr RejectType InvalidUsername =
    Reject_RejectType_InvalidUsername;
  static constexpr RejectType WrongUserPW =
    Reject_RejectType_WrongUserPW;
  static constexpr RejectType WrongServerPW =
    Reject_RejectType_WrongServerPW;
  static constexpr RejectType UsernameInUse =
    Reject_RejectType_UsernameInUse;
  static constexpr RejectType ServerFull =
    Reject_RejectType_ServerFull;
  static constexpr RejectType NoCertificate =
    Reject_RejectType_NoCertificate;
  static constexpr RejectType AuthenticatorFail =
    Reject_RejectType_AuthenticatorFail;
  static inline bool RejectType_IsValid(int value) {
    return Reject_RejectType_IsValid(value);
  }
  static constexpr RejectType RejectType_MIN =
    Reject_RejectType_RejectType_MIN;
  static constexpr RejectType RejectType_MAX =
    Reject_RejectType_RejectType_MAX;
  static constexpr int RejectType_ARRAYSIZE =
    Reject_RejectType_RejectType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RejectType_descriptor() {
    return Reject_RejectType_descriptor();
  }
  template<typename T>
  static inline const std::string& RejectType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RejectType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RejectType_Name.");
    return Reject_RejectType_Name(enum_t_value);
  }
  static inline bool RejectType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RejectType* value) {
    return Reject_RejectType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string reason = 2;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional .MumbleProto.Reject.RejectType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::MumbleProto::Reject_RejectType type() const;
  void set_type(::MumbleProto::Reject_RejectType value);
  private:
  ::MumbleProto::Reject_RejectType _internal_type() const;
  void _internal_set_type(::MumbleProto::Reject_RejectType value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.Reject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  int type_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ServerSync PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ServerSync) */ {
 public:
  inline ServerSync() : ServerSync(nullptr) {};
  virtual ~ServerSync();

  ServerSync(const ServerSync& from);
  ServerSync(ServerSync&& from) noexcept
    : ServerSync() {
    *this = ::std::move(from);
  }

  inline ServerSync& operator=(const ServerSync& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerSync& operator=(ServerSync&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerSync& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerSync* internal_default_instance() {
    return reinterpret_cast<const ServerSync*>(
               &_ServerSync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ServerSync& a, ServerSync& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerSync* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerSync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerSync* New() const final {
    return CreateMaybeMessage<ServerSync>(nullptr);
  }

  ServerSync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerSync>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerSync& from);
  void MergeFrom(const ServerSync& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerSync* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.ServerSync";
  }
  protected:
  explicit ServerSync(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWelcomeTextFieldNumber = 3,
    kSessionFieldNumber = 1,
    kMaxBandwidthFieldNumber = 2,
    kPermissionsFieldNumber = 4,
  };
  // optional string welcome_text = 3;
  bool has_welcome_text() const;
  private:
  bool _internal_has_welcome_text() const;
  public:
  void clear_welcome_text();
  const std::string& welcome_text() const;
  void set_welcome_text(const std::string& value);
  void set_welcome_text(std::string&& value);
  void set_welcome_text(const char* value);
  void set_welcome_text(const char* value, size_t size);
  std::string* mutable_welcome_text();
  std::string* release_welcome_text();
  void set_allocated_welcome_text(std::string* welcome_text);
  private:
  const std::string& _internal_welcome_text() const;
  void _internal_set_welcome_text(const std::string& value);
  std::string* _internal_mutable_welcome_text();
  public:

  // optional uint32 session = 1;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::uint32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 max_bandwidth = 2;
  bool has_max_bandwidth() const;
  private:
  bool _internal_has_max_bandwidth() const;
  public:
  void clear_max_bandwidth();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_bandwidth() const;
  void set_max_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_bandwidth() const;
  void _internal_set_max_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint64 permissions = 4;
  bool has_permissions() const;
  private:
  bool _internal_has_permissions() const;
  public:
  void clear_permissions();
  ::PROTOBUF_NAMESPACE_ID::uint64 permissions() const;
  void set_permissions(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_permissions() const;
  void _internal_set_permissions(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.ServerSync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr welcome_text_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_bandwidth_;
  ::PROTOBUF_NAMESPACE_ID::uint64 permissions_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ChannelRemove PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ChannelRemove) */ {
 public:
  inline ChannelRemove() : ChannelRemove(nullptr) {};
  virtual ~ChannelRemove();

  ChannelRemove(const ChannelRemove& from);
  ChannelRemove(ChannelRemove&& from) noexcept
    : ChannelRemove() {
    *this = ::std::move(from);
  }

  inline ChannelRemove& operator=(const ChannelRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelRemove& operator=(ChannelRemove&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelRemove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelRemove* internal_default_instance() {
    return reinterpret_cast<const ChannelRemove*>(
               &_ChannelRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ChannelRemove& a, ChannelRemove& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelRemove* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelRemove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelRemove* New() const final {
    return CreateMaybeMessage<ChannelRemove>(nullptr);
  }

  ChannelRemove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelRemove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelRemove& from);
  void MergeFrom(const ChannelRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelRemove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.ChannelRemove";
  }
  protected:
  explicit ChannelRemove(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
  };
  // required uint32 channel_id = 1;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id() const;
  void set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id() const;
  void _internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.ChannelRemove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ChannelState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ChannelState) */ {
 public:
  inline ChannelState() : ChannelState(nullptr) {};
  virtual ~ChannelState();

  ChannelState(const ChannelState& from);
  ChannelState(ChannelState&& from) noexcept
    : ChannelState() {
    *this = ::std::move(from);
  }

  inline ChannelState& operator=(const ChannelState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelState& operator=(ChannelState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelState* internal_default_instance() {
    return reinterpret_cast<const ChannelState*>(
               &_ChannelState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChannelState& a, ChannelState& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelState* New() const final {
    return CreateMaybeMessage<ChannelState>(nullptr);
  }

  ChannelState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelState& from);
  void MergeFrom(const ChannelState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.ChannelState";
  }
  protected:
  explicit ChannelState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinksFieldNumber = 4,
    kLinksAddFieldNumber = 6,
    kLinksRemoveFieldNumber = 7,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 5,
    kDescriptionHashFieldNumber = 10,
    kChannelIdFieldNumber = 1,
    kParentFieldNumber = 2,
    kTemporaryFieldNumber = 8,
    kPositionFieldNumber = 9,
    kMaxUsersFieldNumber = 11,
  };
  // repeated uint32 links = 4;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_links(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_links() const;
  void _internal_add_links(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_links();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 links(int index) const;
  void set_links(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_links(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      links() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_links();

  // repeated uint32 links_add = 6;
  int links_add_size() const;
  private:
  int _internal_links_add_size() const;
  public:
  void clear_links_add();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_links_add(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_links_add() const;
  void _internal_add_links_add(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_links_add();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 links_add(int index) const;
  void set_links_add(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_links_add(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      links_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_links_add();

  // repeated uint32 links_remove = 7;
  int links_remove_size() const;
  private:
  int _internal_links_remove_size() const;
  public:
  void clear_links_remove();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_links_remove(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_links_remove() const;
  void _internal_add_links_remove(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_links_remove();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 links_remove(int index) const;
  void set_links_remove(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_links_remove(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      links_remove() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_links_remove();

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string description = 5;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional bytes description_hash = 10;
  bool has_description_hash() const;
  private:
  bool _internal_has_description_hash() const;
  public:
  void clear_description_hash();
  const std::string& description_hash() const;
  void set_description_hash(const std::string& value);
  void set_description_hash(std::string&& value);
  void set_description_hash(const char* value);
  void set_description_hash(const void* value, size_t size);
  std::string* mutable_description_hash();
  std::string* release_description_hash();
  void set_allocated_description_hash(std::string* description_hash);
  private:
  const std::string& _internal_description_hash() const;
  void _internal_set_description_hash(const std::string& value);
  std::string* _internal_mutable_description_hash();
  public:

  // optional uint32 channel_id = 1;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id() const;
  void set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id() const;
  void _internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 parent = 2;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  ::PROTOBUF_NAMESPACE_ID::uint32 parent() const;
  void set_parent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_parent() const;
  void _internal_set_parent(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool temporary = 8 [default = false];
  bool has_temporary() const;
  private:
  bool _internal_has_temporary() const;
  public:
  void clear_temporary();
  bool temporary() const;
  void set_temporary(bool value);
  private:
  bool _internal_temporary() const;
  void _internal_set_temporary(bool value);
  public:

  // optional int32 position = 9 [default = 0];
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::int32 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_position() const;
  void _internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 max_users = 11;
  bool has_max_users() const;
  private:
  bool _internal_has_max_users() const;
  public:
  void clear_max_users();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_users() const;
  void set_max_users(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_users() const;
  void _internal_set_max_users(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.ChannelState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > links_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > links_add_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > links_remove_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 parent_;
  bool temporary_;
  ::PROTOBUF_NAMESPACE_ID::int32 position_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_users_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserRemove PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserRemove) */ {
 public:
  inline UserRemove() : UserRemove(nullptr) {};
  virtual ~UserRemove();

  UserRemove(const UserRemove& from);
  UserRemove(UserRemove&& from) noexcept
    : UserRemove() {
    *this = ::std::move(from);
  }

  inline UserRemove& operator=(const UserRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRemove& operator=(UserRemove&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserRemove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRemove* internal_default_instance() {
    return reinterpret_cast<const UserRemove*>(
               &_UserRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UserRemove& a, UserRemove& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRemove* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRemove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserRemove* New() const final {
    return CreateMaybeMessage<UserRemove>(nullptr);
  }

  UserRemove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserRemove>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserRemove& from);
  void MergeFrom(const UserRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRemove* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.UserRemove";
  }
  protected:
  explicit UserRemove(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 3,
    kSessionFieldNumber = 1,
    kActorFieldNumber = 2,
    kBanFieldNumber = 4,
  };
  // optional string reason = 3;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // required uint32 session = 1;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::uint32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 actor = 2;
  bool has_actor() const;
  private:
  bool _internal_has_actor() const;
  public:
  void clear_actor();
  ::PROTOBUF_NAMESPACE_ID::uint32 actor() const;
  void set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_actor() const;
  void _internal_set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool ban = 4;
  bool has_ban() const;
  private:
  bool _internal_has_ban() const;
  public:
  void clear_ban();
  bool ban() const;
  void set_ban(bool value);
  private:
  bool _internal_ban() const;
  void _internal_set_ban(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.UserRemove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_;
  ::PROTOBUF_NAMESPACE_ID::uint32 actor_;
  bool ban_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserState) */ {
 public:
  inline UserState() : UserState(nullptr) {};
  virtual ~UserState();

  UserState(const UserState& from);
  UserState(UserState&& from) noexcept
    : UserState() {
    *this = ::std::move(from);
  }

  inline UserState& operator=(const UserState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserState& operator=(UserState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserState* internal_default_instance() {
    return reinterpret_cast<const UserState*>(
               &_UserState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UserState& a, UserState& b) {
    a.Swap(&b);
  }
  inline void Swap(UserState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserState* New() const final {
    return CreateMaybeMessage<UserState>(nullptr);
  }

  UserState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserState& from);
  void MergeFrom(const UserState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.UserState";
  }
  protected:
  explicit UserState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kTextureFieldNumber = 11,
    kPluginContextFieldNumber = 12,
    kPluginIdentityFieldNumber = 13,
    kCommentFieldNumber = 14,
    kHashFieldNumber = 15,
    kCommentHashFieldNumber = 16,
    kTextureHashFieldNumber = 17,
    kSessionFieldNumber = 1,
    kActorFieldNumber = 2,
    kUserIdFieldNumber = 4,
    kChannelIdFieldNumber = 5,
    kMuteFieldNumber = 6,
    kDeafFieldNumber = 7,
    kSuppressFieldNumber = 8,
    kSelfMuteFieldNumber = 9,
    kSelfDeafFieldNumber = 10,
    kPrioritySpeakerFieldNumber = 18,
    kRecordingFieldNumber = 19,
  };
  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bytes texture = 11;
  bool has_texture() const;
  private:
  bool _internal_has_texture() const;
  public:
  void clear_texture();
  const std::string& texture() const;
  void set_texture(const std::string& value);
  void set_texture(std::string&& value);
  void set_texture(const char* value);
  void set_texture(const void* value, size_t size);
  std::string* mutable_texture();
  std::string* release_texture();
  void set_allocated_texture(std::string* texture);
  private:
  const std::string& _internal_texture() const;
  void _internal_set_texture(const std::string& value);
  std::string* _internal_mutable_texture();
  public:

  // optional bytes plugin_context = 12;
  bool has_plugin_context() const;
  private:
  bool _internal_has_plugin_context() const;
  public:
  void clear_plugin_context();
  const std::string& plugin_context() const;
  void set_plugin_context(const std::string& value);
  void set_plugin_context(std::string&& value);
  void set_plugin_context(const char* value);
  void set_plugin_context(const void* value, size_t size);
  std::string* mutable_plugin_context();
  std::string* release_plugin_context();
  void set_allocated_plugin_context(std::string* plugin_context);
  private:
  const std::string& _internal_plugin_context() const;
  void _internal_set_plugin_context(const std::string& value);
  std::string* _internal_mutable_plugin_context();
  public:

  // optional string plugin_identity = 13;
  bool has_plugin_identity() const;
  private:
  bool _internal_has_plugin_identity() const;
  public:
  void clear_plugin_identity();
  const std::string& plugin_identity() const;
  void set_plugin_identity(const std::string& value);
  void set_plugin_identity(std::string&& value);
  void set_plugin_identity(const char* value);
  void set_plugin_identity(const char* value, size_t size);
  std::string* mutable_plugin_identity();
  std::string* release_plugin_identity();
  void set_allocated_plugin_identity(std::string* plugin_identity);
  private:
  const std::string& _internal_plugin_identity() const;
  void _internal_set_plugin_identity(const std::string& value);
  std::string* _internal_mutable_plugin_identity();
  public:

  // optional string comment = 14;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  void set_comment(const std::string& value);
  void set_comment(std::string&& value);
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  std::string* mutable_comment();
  std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // optional string hash = 15;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional bytes comment_hash = 16;
  bool has_comment_hash() const;
  private:
  bool _internal_has_comment_hash() const;
  public:
  void clear_comment_hash();
  const std::string& comment_hash() const;
  void set_comment_hash(const std::string& value);
  void set_comment_hash(std::string&& value);
  void set_comment_hash(const char* value);
  void set_comment_hash(const void* value, size_t size);
  std::string* mutable_comment_hash();
  std::string* release_comment_hash();
  void set_allocated_comment_hash(std::string* comment_hash);
  private:
  const std::string& _internal_comment_hash() const;
  void _internal_set_comment_hash(const std::string& value);
  std::string* _internal_mutable_comment_hash();
  public:

  // optional bytes texture_hash = 17;
  bool has_texture_hash() const;
  private:
  bool _internal_has_texture_hash() const;
  public:
  void clear_texture_hash();
  const std::string& texture_hash() const;
  void set_texture_hash(const std::string& value);
  void set_texture_hash(std::string&& value);
  void set_texture_hash(const char* value);
  void set_texture_hash(const void* value, size_t size);
  std::string* mutable_texture_hash();
  std::string* release_texture_hash();
  void set_allocated_texture_hash(std::string* texture_hash);
  private:
  const std::string& _internal_texture_hash() const;
  void _internal_set_texture_hash(const std::string& value);
  std::string* _internal_mutable_texture_hash();
  public:

  // optional uint32 session = 1;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::uint32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 actor = 2;
  bool has_actor() const;
  private:
  bool _internal_has_actor() const;
  public:
  void clear_actor();
  ::PROTOBUF_NAMESPACE_ID::uint32 actor() const;
  void set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_actor() const;
  void _internal_set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 user_id = 4;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 channel_id = 5;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id() const;
  void set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id() const;
  void _internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool mute = 6;
  bool has_mute() const;
  private:
  bool _internal_has_mute() const;
  public:
  void clear_mute();
  bool mute() const;
  void set_mute(bool value);
  private:
  bool _internal_mute() const;
  void _internal_set_mute(bool value);
  public:

  // optional bool deaf = 7;
  bool has_deaf() const;
  private:
  bool _internal_has_deaf() const;
  public:
  void clear_deaf();
  bool deaf() const;
  void set_deaf(bool value);
  private:
  bool _internal_deaf() const;
  void _internal_set_deaf(bool value);
  public:

  // optional bool suppress = 8;
  bool has_suppress() const;
  private:
  bool _internal_has_suppress() const;
  public:
  void clear_suppress();
  bool suppress() const;
  void set_suppress(bool value);
  private:
  bool _internal_suppress() const;
  void _internal_set_suppress(bool value);
  public:

  // optional bool self_mute = 9;
  bool has_self_mute() const;
  private:
  bool _internal_has_self_mute() const;
  public:
  void clear_self_mute();
  bool self_mute() const;
  void set_self_mute(bool value);
  private:
  bool _internal_self_mute() const;
  void _internal_set_self_mute(bool value);
  public:

  // optional bool self_deaf = 10;
  bool has_self_deaf() const;
  private:
  bool _internal_has_self_deaf() const;
  public:
  void clear_self_deaf();
  bool self_deaf() const;
  void set_self_deaf(bool value);
  private:
  bool _internal_self_deaf() const;
  void _internal_set_self_deaf(bool value);
  public:

  // optional bool priority_speaker = 18;
  bool has_priority_speaker() const;
  private:
  bool _internal_has_priority_speaker() const;
  public:
  void clear_priority_speaker();
  bool priority_speaker() const;
  void set_priority_speaker(bool value);
  private:
  bool _internal_priority_speaker() const;
  void _internal_set_priority_speaker(bool value);
  public:

  // optional bool recording = 19;
  bool has_recording() const;
  private:
  bool _internal_has_recording() const;
  public:
  void clear_recording();
  bool recording() const;
  void set_recording(bool value);
  private:
  bool _internal_recording() const;
  void _internal_set_recording(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.UserState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr texture_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_context_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plugin_identity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr texture_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_;
  ::PROTOBUF_NAMESPACE_ID::uint32 actor_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id_;
  bool mute_;
  bool deaf_;
  bool suppress_;
  bool self_mute_;
  bool self_deaf_;
  bool priority_speaker_;
  bool recording_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class BanList_BanEntry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.BanList.BanEntry) */ {
 public:
  inline BanList_BanEntry() : BanList_BanEntry(nullptr) {};
  virtual ~BanList_BanEntry();

  BanList_BanEntry(const BanList_BanEntry& from);
  BanList_BanEntry(BanList_BanEntry&& from) noexcept
    : BanList_BanEntry() {
    *this = ::std::move(from);
  }

  inline BanList_BanEntry& operator=(const BanList_BanEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline BanList_BanEntry& operator=(BanList_BanEntry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BanList_BanEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BanList_BanEntry* internal_default_instance() {
    return reinterpret_cast<const BanList_BanEntry*>(
               &_BanList_BanEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BanList_BanEntry& a, BanList_BanEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(BanList_BanEntry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BanList_BanEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BanList_BanEntry* New() const final {
    return CreateMaybeMessage<BanList_BanEntry>(nullptr);
  }

  BanList_BanEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BanList_BanEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BanList_BanEntry& from);
  void MergeFrom(const BanList_BanEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BanList_BanEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.BanList.BanEntry";
  }
  protected:
  explicit BanList_BanEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kNameFieldNumber = 3,
    kHashFieldNumber = 4,
    kReasonFieldNumber = 5,
    kStartFieldNumber = 6,
    kMaskFieldNumber = 2,
    kDurationFieldNumber = 7,
  };
  // required bytes address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string hash = 4;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional string reason = 5;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional string start = 6;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const std::string& start() const;
  void set_start(const std::string& value);
  void set_start(std::string&& value);
  void set_start(const char* value);
  void set_start(const char* value, size_t size);
  std::string* mutable_start();
  std::string* release_start();
  void set_allocated_start(std::string* start);
  private:
  const std::string& _internal_start() const;
  void _internal_set_start(const std::string& value);
  std::string* _internal_mutable_start();
  public:

  // required uint32 mask = 2;
  bool has_mask() const;
  private:
  bool _internal_has_mask() const;
  public:
  void clear_mask();
  ::PROTOBUF_NAMESPACE_ID::uint32 mask() const;
  void set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mask() const;
  void _internal_set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 duration = 7;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  ::PROTOBUF_NAMESPACE_ID::uint32 duration() const;
  void set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_duration() const;
  void _internal_set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.BanList.BanEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mask_;
  ::PROTOBUF_NAMESPACE_ID::uint32 duration_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class BanList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.BanList) */ {
 public:
  inline BanList() : BanList(nullptr) {};
  virtual ~BanList();

  BanList(const BanList& from);
  BanList(BanList&& from) noexcept
    : BanList() {
    *this = ::std::move(from);
  }

  inline BanList& operator=(const BanList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BanList& operator=(BanList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BanList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BanList* internal_default_instance() {
    return reinterpret_cast<const BanList*>(
               &_BanList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BanList& a, BanList& b) {
    a.Swap(&b);
  }
  inline void Swap(BanList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BanList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BanList* New() const final {
    return CreateMaybeMessage<BanList>(nullptr);
  }

  BanList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BanList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BanList& from);
  void MergeFrom(const BanList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BanList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.BanList";
  }
  protected:
  explicit BanList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BanList_BanEntry BanEntry;

  // accessors -------------------------------------------------------

  enum : int {
    kBansFieldNumber = 1,
    kQueryFieldNumber = 2,
  };
  // repeated .MumbleProto.BanList.BanEntry bans = 1;
  int bans_size() const;
  private:
  int _internal_bans_size() const;
  public:
  void clear_bans();
  ::MumbleProto::BanList_BanEntry* mutable_bans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
      mutable_bans();
  private:
  const ::MumbleProto::BanList_BanEntry& _internal_bans(int index) const;
  ::MumbleProto::BanList_BanEntry* _internal_add_bans();
  public:
  const ::MumbleProto::BanList_BanEntry& bans(int index) const;
  ::MumbleProto::BanList_BanEntry* add_bans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
      bans() const;

  // optional bool query = 2 [default = false];
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  bool query() const;
  void set_query(bool value);
  private:
  bool _internal_query() const;
  void _internal_set_query(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.BanList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::BanList_BanEntry > bans_;
  bool query_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class TextMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.TextMessage) */ {
 public:
  inline TextMessage() : TextMessage(nullptr) {};
  virtual ~TextMessage();

  TextMessage(const TextMessage& from);
  TextMessage(TextMessage&& from) noexcept
    : TextMessage() {
    *this = ::std::move(from);
  }

  inline TextMessage& operator=(const TextMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextMessage& operator=(TextMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TextMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextMessage* internal_default_instance() {
    return reinterpret_cast<const TextMessage*>(
               &_TextMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TextMessage& a, TextMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TextMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TextMessage* New() const final {
    return CreateMaybeMessage<TextMessage>(nullptr);
  }

  TextMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TextMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TextMessage& from);
  void MergeFrom(const TextMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.TextMessage";
  }
  protected:
  explicit TextMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 2,
    kChannelIdFieldNumber = 3,
    kTreeIdFieldNumber = 4,
    kMessageFieldNumber = 5,
    kActorFieldNumber = 1,
  };
  // repeated uint32 session = 2;
  int session_size() const;
  private:
  int _internal_session_size() const;
  public:
  void clear_session();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_session() const;
  void _internal_add_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_session();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 session(int index) const;
  void set_session(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      session() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_session();

  // repeated uint32 channel_id = 3;
  int channel_id_size() const;
  private:
  int _internal_channel_id_size() const;
  public:
  void clear_channel_id();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_channel_id() const;
  void _internal_add_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_channel_id();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id(int index) const;
  void set_channel_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      channel_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_channel_id();

  // repeated uint32 tree_id = 4;
  int tree_id_size() const;
  private:
  int _internal_tree_id_size() const;
  public:
  void clear_tree_id();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tree_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_tree_id() const;
  void _internal_add_tree_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_tree_id();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 tree_id(int index) const;
  void set_tree_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_tree_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      tree_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_tree_id();

  // required string message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional uint32 actor = 1;
  bool has_actor() const;
  private:
  bool _internal_has_actor() const;
  public:
  void clear_actor();
  ::PROTOBUF_NAMESPACE_ID::uint32 actor() const;
  void set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_actor() const;
  void _internal_set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.TextMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > session_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > channel_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > tree_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint32 actor_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class PermissionDenied PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.PermissionDenied) */ {
 public:
  inline PermissionDenied() : PermissionDenied(nullptr) {};
  virtual ~PermissionDenied();

  PermissionDenied(const PermissionDenied& from);
  PermissionDenied(PermissionDenied&& from) noexcept
    : PermissionDenied() {
    *this = ::std::move(from);
  }

  inline PermissionDenied& operator=(const PermissionDenied& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionDenied& operator=(PermissionDenied&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PermissionDenied& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PermissionDenied* internal_default_instance() {
    return reinterpret_cast<const PermissionDenied*>(
               &_PermissionDenied_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PermissionDenied& a, PermissionDenied& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionDenied* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionDenied* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PermissionDenied* New() const final {
    return CreateMaybeMessage<PermissionDenied>(nullptr);
  }

  PermissionDenied* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PermissionDenied>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PermissionDenied& from);
  void MergeFrom(const PermissionDenied& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionDenied* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.PermissionDenied";
  }
  protected:
  explicit PermissionDenied(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PermissionDenied_DenyType DenyType;
  static constexpr DenyType Text =
    PermissionDenied_DenyType_Text;
  static constexpr DenyType Permission =
    PermissionDenied_DenyType_Permission;
  static constexpr DenyType SuperUser =
    PermissionDenied_DenyType_SuperUser;
  static constexpr DenyType ChannelName =
    PermissionDenied_DenyType_ChannelName;
  static constexpr DenyType TextTooLong =
    PermissionDenied_DenyType_TextTooLong;
  static constexpr DenyType H9K =
    PermissionDenied_DenyType_H9K;
  static constexpr DenyType TemporaryChannel =
    PermissionDenied_DenyType_TemporaryChannel;
  static constexpr DenyType MissingCertificate =
    PermissionDenied_DenyType_MissingCertificate;
  static constexpr DenyType UserName =
    PermissionDenied_DenyType_UserName;
  static constexpr DenyType ChannelFull =
    PermissionDenied_DenyType_ChannelFull;
  static constexpr DenyType NestingLimit =
    PermissionDenied_DenyType_NestingLimit;
  static inline bool DenyType_IsValid(int value) {
    return PermissionDenied_DenyType_IsValid(value);
  }
  static constexpr DenyType DenyType_MIN =
    PermissionDenied_DenyType_DenyType_MIN;
  static constexpr DenyType DenyType_MAX =
    PermissionDenied_DenyType_DenyType_MAX;
  static constexpr int DenyType_ARRAYSIZE =
    PermissionDenied_DenyType_DenyType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DenyType_descriptor() {
    return PermissionDenied_DenyType_descriptor();
  }
  template<typename T>
  static inline const std::string& DenyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DenyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DenyType_Name.");
    return PermissionDenied_DenyType_Name(enum_t_value);
  }
  static inline bool DenyType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DenyType* value) {
    return PermissionDenied_DenyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 4,
    kNameFieldNumber = 6,
    kPermissionFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kSessionFieldNumber = 3,
    kTypeFieldNumber = 5,
  };
  // optional string reason = 4;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional string name = 6;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 permission = 1;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  ::PROTOBUF_NAMESPACE_ID::uint32 permission() const;
  void set_permission(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_permission() const;
  void _internal_set_permission(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id() const;
  void set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id() const;
  void _internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 session = 3;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::uint32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .MumbleProto.PermissionDenied.DenyType type = 5;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::MumbleProto::PermissionDenied_DenyType type() const;
  void set_type(::MumbleProto::PermissionDenied_DenyType value);
  private:
  ::MumbleProto::PermissionDenied_DenyType _internal_type() const;
  void _internal_set_type(::MumbleProto::PermissionDenied_DenyType value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.PermissionDenied)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 permission_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_;
  int type_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ACL_ChanGroup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ACL.ChanGroup) */ {
 public:
  inline ACL_ChanGroup() : ACL_ChanGroup(nullptr) {};
  virtual ~ACL_ChanGroup();

  ACL_ChanGroup(const ACL_ChanGroup& from);
  ACL_ChanGroup(ACL_ChanGroup&& from) noexcept
    : ACL_ChanGroup() {
    *this = ::std::move(from);
  }

  inline ACL_ChanGroup& operator=(const ACL_ChanGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACL_ChanGroup& operator=(ACL_ChanGroup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ACL_ChanGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ChanGroup* internal_default_instance() {
    return reinterpret_cast<const ACL_ChanGroup*>(
               &_ACL_ChanGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ACL_ChanGroup& a, ACL_ChanGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ACL_ChanGroup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACL_ChanGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ACL_ChanGroup* New() const final {
    return CreateMaybeMessage<ACL_ChanGroup>(nullptr);
  }

  ACL_ChanGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ACL_ChanGroup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ACL_ChanGroup& from);
  void MergeFrom(const ACL_ChanGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL_ChanGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.ACL.ChanGroup";
  }
  protected:
  explicit ACL_ChanGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddFieldNumber = 5,
    kRemoveFieldNumber = 6,
    kInheritedMembersFieldNumber = 7,
    kNameFieldNumber = 1,
    kInheritedFieldNumber = 2,
    kInheritFieldNumber = 3,
    kInheritableFieldNumber = 4,
  };
  // repeated uint32 add = 5;
  int add_size() const;
  private:
  int _internal_add_size() const;
  public:
  void clear_add();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_add(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_add() const;
  void _internal_add_add(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_add();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 add(int index) const;
  void set_add(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_add(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_add();

  // repeated uint32 remove = 6;
  int remove_size() const;
  private:
  int _internal_remove_size() const;
  public:
  void clear_remove();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_remove(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_remove() const;
  void _internal_add_remove(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_remove();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 remove(int index) const;
  void set_remove(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_remove(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      remove() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_remove();

  // repeated uint32 inherited_members = 7;
  int inherited_members_size() const;
  private:
  int _internal_inherited_members_size() const;
  public:
  void clear_inherited_members();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_inherited_members(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_inherited_members() const;
  void _internal_add_inherited_members(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_inherited_members();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 inherited_members(int index) const;
  void set_inherited_members(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_inherited_members(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      inherited_members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_inherited_members();

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool inherited = 2 [default = true];
  bool has_inherited() const;
  private:
  bool _internal_has_inherited() const;
  public:
  void clear_inherited();
  bool inherited() const;
  void set_inherited(bool value);
  private:
  bool _internal_inherited() const;
  void _internal_set_inherited(bool value);
  public:

  // optional bool inherit = 3 [default = true];
  bool has_inherit() const;
  private:
  bool _internal_has_inherit() const;
  public:
  void clear_inherit();
  bool inherit() const;
  void set_inherit(bool value);
  private:
  bool _internal_inherit() const;
  void _internal_set_inherit(bool value);
  public:

  // optional bool inheritable = 4 [default = true];
  bool has_inheritable() const;
  private:
  bool _internal_has_inheritable() const;
  public:
  void clear_inheritable();
  bool inheritable() const;
  void set_inheritable(bool value);
  private:
  bool _internal_inheritable() const;
  void _internal_set_inheritable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > add_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > remove_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > inherited_members_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool inherited_;
  bool inherit_;
  bool inheritable_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ACL_ChanACL PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ACL.ChanACL) */ {
 public:
  inline ACL_ChanACL() : ACL_ChanACL(nullptr) {};
  virtual ~ACL_ChanACL();

  ACL_ChanACL(const ACL_ChanACL& from);
  ACL_ChanACL(ACL_ChanACL&& from) noexcept
    : ACL_ChanACL() {
    *this = ::std::move(from);
  }

  inline ACL_ChanACL& operator=(const ACL_ChanACL& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACL_ChanACL& operator=(ACL_ChanACL&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ACL_ChanACL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ChanACL* internal_default_instance() {
    return reinterpret_cast<const ACL_ChanACL*>(
               &_ACL_ChanACL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ACL_ChanACL& a, ACL_ChanACL& b) {
    a.Swap(&b);
  }
  inline void Swap(ACL_ChanACL* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACL_ChanACL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ACL_ChanACL* New() const final {
    return CreateMaybeMessage<ACL_ChanACL>(nullptr);
  }

  ACL_ChanACL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ACL_ChanACL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ACL_ChanACL& from);
  void MergeFrom(const ACL_ChanACL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL_ChanACL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.ACL.ChanACL";
  }
  protected:
  explicit ACL_ChanACL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 5,
    kUserIdFieldNumber = 4,
    kGrantFieldNumber = 6,
    kDenyFieldNumber = 7,
    kApplyHereFieldNumber = 1,
    kApplySubsFieldNumber = 2,
    kInheritedFieldNumber = 3,
  };
  // optional string group = 5;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  void set_group(const std::string& value);
  void set_group(std::string&& value);
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  std::string* mutable_group();
  std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional uint32 user_id = 4;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 grant = 6;
  bool has_grant() const;
  private:
  bool _internal_has_grant() const;
  public:
  void clear_grant();
  ::PROTOBUF_NAMESPACE_ID::uint32 grant() const;
  void set_grant(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_grant() const;
  void _internal_set_grant(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 deny = 7;
  bool has_deny() const;
  private:
  bool _internal_has_deny() const;
  public:
  void clear_deny();
  ::PROTOBUF_NAMESPACE_ID::uint32 deny() const;
  void set_deny(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_deny() const;
  void _internal_set_deny(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool apply_here = 1 [default = true];
  bool has_apply_here() const;
  private:
  bool _internal_has_apply_here() const;
  public:
  void clear_apply_here();
  bool apply_here() const;
  void set_apply_here(bool value);
  private:
  bool _internal_apply_here() const;
  void _internal_set_apply_here(bool value);
  public:

  // optional bool apply_subs = 2 [default = true];
  bool has_apply_subs() const;
  private:
  bool _internal_has_apply_subs() const;
  public:
  void clear_apply_subs();
  bool apply_subs() const;
  void set_apply_subs(bool value);
  private:
  bool _internal_apply_subs() const;
  void _internal_set_apply_subs(bool value);
  public:

  // optional bool inherited = 3 [default = true];
  bool has_inherited() const;
  private:
  bool _internal_has_inherited() const;
  public:
  void clear_inherited();
  bool inherited() const;
  void set_inherited(bool value);
  private:
  bool _internal_inherited() const;
  void _internal_set_inherited(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanACL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 grant_;
  ::PROTOBUF_NAMESPACE_ID::uint32 deny_;
  bool apply_here_;
  bool apply_subs_;
  bool inherited_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ACL PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ACL) */ {
 public:
  inline ACL() : ACL(nullptr) {};
  virtual ~ACL();

  ACL(const ACL& from);
  ACL(ACL&& from) noexcept
    : ACL() {
    *this = ::std::move(from);
  }

  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACL& operator=(ACL&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ACL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL* internal_default_instance() {
    return reinterpret_cast<const ACL*>(
               &_ACL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ACL& a, ACL& b) {
    a.Swap(&b);
  }
  inline void Swap(ACL* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACL* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ACL* New() const final {
    return CreateMaybeMessage<ACL>(nullptr);
  }

  ACL* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ACL>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.ACL";
  }
  protected:
  explicit ACL(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ACL_ChanGroup ChanGroup;
  typedef ACL_ChanACL ChanACL;

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 3,
    kAclsFieldNumber = 4,
    kChannelIdFieldNumber = 1,
    kQueryFieldNumber = 5,
    kInheritAclsFieldNumber = 2,
  };
  // repeated .MumbleProto.ACL.ChanGroup groups = 3;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::MumbleProto::ACL_ChanGroup* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
      mutable_groups();
  private:
  const ::MumbleProto::ACL_ChanGroup& _internal_groups(int index) const;
  ::MumbleProto::ACL_ChanGroup* _internal_add_groups();
  public:
  const ::MumbleProto::ACL_ChanGroup& groups(int index) const;
  ::MumbleProto::ACL_ChanGroup* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
      groups() const;

  // repeated .MumbleProto.ACL.ChanACL acls = 4;
  int acls_size() const;
  private:
  int _internal_acls_size() const;
  public:
  void clear_acls();
  ::MumbleProto::ACL_ChanACL* mutable_acls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
      mutable_acls();
  private:
  const ::MumbleProto::ACL_ChanACL& _internal_acls(int index) const;
  ::MumbleProto::ACL_ChanACL* _internal_add_acls();
  public:
  const ::MumbleProto::ACL_ChanACL& acls(int index) const;
  ::MumbleProto::ACL_ChanACL* add_acls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
      acls() const;

  // required uint32 channel_id = 1;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id() const;
  void set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id() const;
  void _internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool query = 5 [default = false];
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  bool query() const;
  void set_query(bool value);
  private:
  bool _internal_query() const;
  void _internal_set_query(bool value);
  public:

  // optional bool inherit_acls = 2 [default = true];
  bool has_inherit_acls() const;
  private:
  bool _internal_has_inherit_acls() const;
  public:
  void clear_inherit_acls();
  bool inherit_acls() const;
  void set_inherit_acls(bool value);
  private:
  bool _internal_inherit_acls() const;
  void _internal_set_inherit_acls(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.ACL)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup > groups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanACL > acls_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id_;
  bool query_;
  bool inherit_acls_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class QueryUsers PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.QueryUsers) */ {
 public:
  inline QueryUsers() : QueryUsers(nullptr) {};
  virtual ~QueryUsers();

  QueryUsers(const QueryUsers& from);
  QueryUsers(QueryUsers&& from) noexcept
    : QueryUsers() {
    *this = ::std::move(from);
  }

  inline QueryUsers& operator=(const QueryUsers& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryUsers& operator=(QueryUsers&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QueryUsers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryUsers* internal_default_instance() {
    return reinterpret_cast<const QueryUsers*>(
               &_QueryUsers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(QueryUsers& a, QueryUsers& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryUsers* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryUsers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryUsers* New() const final {
    return CreateMaybeMessage<QueryUsers>(nullptr);
  }

  QueryUsers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryUsers>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QueryUsers& from);
  void MergeFrom(const QueryUsers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryUsers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.QueryUsers";
  }
  protected:
  explicit QueryUsers(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
    kNamesFieldNumber = 2,
  };
  // repeated uint32 ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_ids() const;
  void _internal_add_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 ids(int index) const;
  void set_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_ids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_ids();

  // repeated string names = 2;
  int names_size() const;
  private:
  int _internal_names_size() const;
  public:
  void clear_names();
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_names();
  private:
  const std::string& _internal_names(int index) const;
  std::string* _internal_add_names();
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.QueryUsers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> names_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class CryptSetup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.CryptSetup) */ {
 public:
  inline CryptSetup() : CryptSetup(nullptr) {};
  virtual ~CryptSetup();

  CryptSetup(const CryptSetup& from);
  CryptSetup(CryptSetup&& from) noexcept
    : CryptSetup() {
    *this = ::std::move(from);
  }

  inline CryptSetup& operator=(const CryptSetup& from) {
    CopyFrom(from);
    return *this;
  }
  inline CryptSetup& operator=(CryptSetup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CryptSetup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CryptSetup* internal_default_instance() {
    return reinterpret_cast<const CryptSetup*>(
               &_CryptSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CryptSetup& a, CryptSetup& b) {
    a.Swap(&b);
  }
  inline void Swap(CryptSetup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CryptSetup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CryptSetup* New() const final {
    return CreateMaybeMessage<CryptSetup>(nullptr);
  }

  CryptSetup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CryptSetup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CryptSetup& from);
  void MergeFrom(const CryptSetup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CryptSetup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.CryptSetup";
  }
  protected:
  explicit CryptSetup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kClientNonceFieldNumber = 2,
    kServerNonceFieldNumber = 3,
  };
  // optional bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional bytes client_nonce = 2;
  bool has_client_nonce() const;
  private:
  bool _internal_has_client_nonce() const;
  public:
  void clear_client_nonce();
  const std::string& client_nonce() const;
  void set_client_nonce(const std::string& value);
  void set_client_nonce(std::string&& value);
  void set_client_nonce(const char* value);
  void set_client_nonce(const void* value, size_t size);
  std::string* mutable_client_nonce();
  std::string* release_client_nonce();
  void set_allocated_client_nonce(std::string* client_nonce);
  private:
  const std::string& _internal_client_nonce() const;
  void _internal_set_client_nonce(const std::string& value);
  std::string* _internal_mutable_client_nonce();
  public:

  // optional bytes server_nonce = 3;
  bool has_server_nonce() const;
  private:
  bool _internal_has_server_nonce() const;
  public:
  void clear_server_nonce();
  const std::string& server_nonce() const;
  void set_server_nonce(const std::string& value);
  void set_server_nonce(std::string&& value);
  void set_server_nonce(const char* value);
  void set_server_nonce(const void* value, size_t size);
  std::string* mutable_server_nonce();
  std::string* release_server_nonce();
  void set_allocated_server_nonce(std::string* server_nonce);
  private:
  const std::string& _internal_server_nonce() const;
  void _internal_set_server_nonce(const std::string& value);
  std::string* _internal_mutable_server_nonce();
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.CryptSetup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_nonce_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_nonce_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ContextActionModify PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ContextActionModify) */ {
 public:
  inline ContextActionModify() : ContextActionModify(nullptr) {};
  virtual ~ContextActionModify();

  ContextActionModify(const ContextActionModify& from);
  ContextActionModify(ContextActionModify&& from) noexcept
    : ContextActionModify() {
    *this = ::std::move(from);
  }

  inline ContextActionModify& operator=(const ContextActionModify& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextActionModify& operator=(ContextActionModify&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContextActionModify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContextActionModify* internal_default_instance() {
    return reinterpret_cast<const ContextActionModify*>(
               &_ContextActionModify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ContextActionModify& a, ContextActionModify& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextActionModify* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextActionModify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContextActionModify* New() const final {
    return CreateMaybeMessage<ContextActionModify>(nullptr);
  }

  ContextActionModify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContextActionModify>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContextActionModify& from);
  void MergeFrom(const ContextActionModify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextActionModify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.ContextActionModify";
  }
  protected:
  explicit ContextActionModify(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ContextActionModify_Context Context;
  static constexpr Context Server =
    ContextActionModify_Context_Server;
  static constexpr Context Channel =
    ContextActionModify_Context_Channel;
  static constexpr Context User =
    ContextActionModify_Context_User;
  static inline bool Context_IsValid(int value) {
    return ContextActionModify_Context_IsValid(value);
  }
  static constexpr Context Context_MIN =
    ContextActionModify_Context_Context_MIN;
  static constexpr Context Context_MAX =
    ContextActionModify_Context_Context_MAX;
  static constexpr int Context_ARRAYSIZE =
    ContextActionModify_Context_Context_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Context_descriptor() {
    return ContextActionModify_Context_descriptor();
  }
  template<typename T>
  static inline const std::string& Context_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Context>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Context_Name.");
    return ContextActionModify_Context_Name(enum_t_value);
  }
  static inline bool Context_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Context* value) {
    return ContextActionModify_Context_Parse(name, value);
  }

  typedef ContextActionModify_Operation Operation;
  static constexpr Operation Add =
    ContextActionModify_Operation_Add;
  static constexpr Operation Remove =
    ContextActionModify_Operation_Remove;
  static inline bool Operation_IsValid(int value) {
    return ContextActionModify_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    ContextActionModify_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    ContextActionModify_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    ContextActionModify_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return ContextActionModify_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return ContextActionModify_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operation* value) {
    return ContextActionModify_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kTextFieldNumber = 2,
    kContextFieldNumber = 3,
    kOperationFieldNumber = 4,
  };
  // required string action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const std::string& action() const;
  void set_action(const std::string& value);
  void set_action(std::string&& value);
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  std::string* mutable_action();
  std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // optional string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional uint32 context = 3;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  ::PROTOBUF_NAMESPACE_ID::uint32 context() const;
  void set_context(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_context() const;
  void _internal_set_context(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .MumbleProto.ContextActionModify.Operation operation = 4;
  bool has_operation() const;
  private:
  bool _internal_has_operation() const;
  public:
  void clear_operation();
  ::MumbleProto::ContextActionModify_Operation operation() const;
  void set_operation(::MumbleProto::ContextActionModify_Operation value);
  private:
  ::MumbleProto::ContextActionModify_Operation _internal_operation() const;
  void _internal_set_operation(::MumbleProto::ContextActionModify_Operation value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.ContextActionModify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::uint32 context_;
  int operation_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ContextAction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ContextAction) */ {
 public:
  inline ContextAction() : ContextAction(nullptr) {};
  virtual ~ContextAction();

  ContextAction(const ContextAction& from);
  ContextAction(ContextAction&& from) noexcept
    : ContextAction() {
    *this = ::std::move(from);
  }

  inline ContextAction& operator=(const ContextAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextAction& operator=(ContextAction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ContextAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContextAction* internal_default_instance() {
    return reinterpret_cast<const ContextAction*>(
               &_ContextAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ContextAction& a, ContextAction& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextAction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContextAction* New() const final {
    return CreateMaybeMessage<ContextAction>(nullptr);
  }

  ContextAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContextAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ContextAction& from);
  void MergeFrom(const ContextAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.ContextAction";
  }
  protected:
  explicit ContextAction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 3,
    kSessionFieldNumber = 1,
    kChannelIdFieldNumber = 2,
  };
  // required string action = 3;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const std::string& action() const;
  void set_action(const std::string& value);
  void set_action(std::string&& value);
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  std::string* mutable_action();
  std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // optional uint32 session = 1;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::uint32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id() const;
  void set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id() const;
  void _internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.ContextAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserList_User PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserList.User) */ {
 public:
  inline UserList_User() : UserList_User(nullptr) {};
  virtual ~UserList_User();

  UserList_User(const UserList_User& from);
  UserList_User(UserList_User&& from) noexcept
    : UserList_User() {
    *this = ::std::move(from);
  }

  inline UserList_User& operator=(const UserList_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserList_User& operator=(UserList_User&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserList_User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserList_User* internal_default_instance() {
    return reinterpret_cast<const UserList_User*>(
               &_UserList_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UserList_User& a, UserList_User& b) {
    a.Swap(&b);
  }
  inline void Swap(UserList_User* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserList_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserList_User* New() const final {
    return CreateMaybeMessage<UserList_User>(nullptr);
  }

  UserList_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserList_User>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserList_User& from);
  void MergeFrom(const UserList_User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserList_User* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.UserList.User";
  }
  protected:
  explicit UserList_User(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kLastSeenFieldNumber = 3,
    kUserIdFieldNumber = 1,
    kLastChannelFieldNumber = 4,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string last_seen = 3;
  bool has_last_seen() const;
  private:
  bool _internal_has_last_seen() const;
  public:
  void clear_last_seen();
  const std::string& last_seen() const;
  void set_last_seen(const std::string& value);
  void set_last_seen(std::string&& value);
  void set_last_seen(const char* value);
  void set_last_seen(const char* value, size_t size);
  std::string* mutable_last_seen();
  std::string* release_last_seen();
  void set_allocated_last_seen(std::string* last_seen);
  private:
  const std::string& _internal_last_seen() const;
  void _internal_set_last_seen(const std::string& value);
  std::string* _internal_mutable_last_seen();
  public:

  // required uint32 user_id = 1;
  bool has_user_id() const;
  private:
  bool _internal_has_user_id() const;
  public:
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 last_channel = 4;
  bool has_last_channel() const;
  private:
  bool _internal_has_last_channel() const;
  public:
  void clear_last_channel();
  ::PROTOBUF_NAMESPACE_ID::uint32 last_channel() const;
  void set_last_channel(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_last_channel() const;
  void _internal_set_last_channel(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.UserList.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_seen_;
  ::PROTOBUF_NAMESPACE_ID::uint32 user_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 last_channel_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserList) */ {
 public:
  inline UserList() : UserList(nullptr) {};
  virtual ~UserList();

  UserList(const UserList& from);
  UserList(UserList&& from) noexcept
    : UserList() {
    *this = ::std::move(from);
  }

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserList& operator=(UserList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UserList& a, UserList& b) {
    a.Swap(&b);
  }
  inline void Swap(UserList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserList* New() const final {
    return CreateMaybeMessage<UserList>(nullptr);
  }

  UserList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.UserList";
  }
  protected:
  explicit UserList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UserList_User User;

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated .MumbleProto.UserList.User users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::MumbleProto::UserList_User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::UserList_User >*
      mutable_users();
  private:
  const ::MumbleProto::UserList_User& _internal_users(int index) const;
  ::MumbleProto::UserList_User* _internal_add_users();
  public:
  const ::MumbleProto::UserList_User& users(int index) const;
  ::MumbleProto::UserList_User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::UserList_User >&
      users() const;

  // @@protoc_insertion_point(class_scope:MumbleProto.UserList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::UserList_User > users_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class VoiceTarget_Target PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.VoiceTarget.Target) */ {
 public:
  inline VoiceTarget_Target() : VoiceTarget_Target(nullptr) {};
  virtual ~VoiceTarget_Target();

  VoiceTarget_Target(const VoiceTarget_Target& from);
  VoiceTarget_Target(VoiceTarget_Target&& from) noexcept
    : VoiceTarget_Target() {
    *this = ::std::move(from);
  }

  inline VoiceTarget_Target& operator=(const VoiceTarget_Target& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceTarget_Target& operator=(VoiceTarget_Target&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VoiceTarget_Target& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoiceTarget_Target* internal_default_instance() {
    return reinterpret_cast<const VoiceTarget_Target*>(
               &_VoiceTarget_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(VoiceTarget_Target& a, VoiceTarget_Target& b) {
    a.Swap(&b);
  }
  inline void Swap(VoiceTarget_Target* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceTarget_Target* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoiceTarget_Target* New() const final {
    return CreateMaybeMessage<VoiceTarget_Target>(nullptr);
  }

  VoiceTarget_Target* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoiceTarget_Target>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VoiceTarget_Target& from);
  void MergeFrom(const VoiceTarget_Target& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceTarget_Target* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.VoiceTarget.Target";
  }
  protected:
  explicit VoiceTarget_Target(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kGroupFieldNumber = 3,
    kChannelIdFieldNumber = 2,
    kLinksFieldNumber = 4,
    kChildrenFieldNumber = 5,
  };
  // repeated uint32 session = 1;
  int session_size() const;
  private:
  int _internal_session_size() const;
  public:
  void clear_session();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_session() const;
  void _internal_add_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_session();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 session(int index) const;
  void set_session(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      session() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_session();

  // optional string group = 3;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  void set_group(const std::string& value);
  void set_group(std::string&& value);
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  std::string* mutable_group();
  std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // optional uint32 channel_id = 2;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id() const;
  void set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id() const;
  void _internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool links = 4 [default = false];
  bool has_links() const;
  private:
  bool _internal_has_links() const;
  public:
  void clear_links();
  bool links() const;
  void set_links(bool value);
  private:
  bool _internal_links() const;
  void _internal_set_links(bool value);
  public:

  // optional bool children = 5 [default = false];
  bool has_children() const;
  private:
  bool _internal_has_children() const;
  public:
  void clear_children();
  bool children() const;
  void set_children(bool value);
  private:
  bool _internal_children() const;
  void _internal_set_children(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget.Target)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > session_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id_;
  bool links_;
  bool children_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class VoiceTarget PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.VoiceTarget) */ {
 public:
  inline VoiceTarget() : VoiceTarget(nullptr) {};
  virtual ~VoiceTarget();

  VoiceTarget(const VoiceTarget& from);
  VoiceTarget(VoiceTarget&& from) noexcept
    : VoiceTarget() {
    *this = ::std::move(from);
  }

  inline VoiceTarget& operator=(const VoiceTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceTarget& operator=(VoiceTarget&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VoiceTarget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoiceTarget* internal_default_instance() {
    return reinterpret_cast<const VoiceTarget*>(
               &_VoiceTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(VoiceTarget& a, VoiceTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(VoiceTarget* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoiceTarget* New() const final {
    return CreateMaybeMessage<VoiceTarget>(nullptr);
  }

  VoiceTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoiceTarget>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VoiceTarget& from);
  void MergeFrom(const VoiceTarget& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceTarget* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.VoiceTarget";
  }
  protected:
  explicit VoiceTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VoiceTarget_Target Target;

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .MumbleProto.VoiceTarget.Target targets = 2;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::MumbleProto::VoiceTarget_Target* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
      mutable_targets();
  private:
  const ::MumbleProto::VoiceTarget_Target& _internal_targets(int index) const;
  ::MumbleProto::VoiceTarget_Target* _internal_add_targets();
  public:
  const ::MumbleProto::VoiceTarget_Target& targets(int index) const;
  ::MumbleProto::VoiceTarget_Target* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
      targets() const;

  // optional uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target > targets_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class PermissionQuery PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.PermissionQuery) */ {
 public:
  inline PermissionQuery() : PermissionQuery(nullptr) {};
  virtual ~PermissionQuery();

  PermissionQuery(const PermissionQuery& from);
  PermissionQuery(PermissionQuery&& from) noexcept
    : PermissionQuery() {
    *this = ::std::move(from);
  }

  inline PermissionQuery& operator=(const PermissionQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionQuery& operator=(PermissionQuery&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PermissionQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PermissionQuery* internal_default_instance() {
    return reinterpret_cast<const PermissionQuery*>(
               &_PermissionQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(PermissionQuery& a, PermissionQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionQuery* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PermissionQuery* New() const final {
    return CreateMaybeMessage<PermissionQuery>(nullptr);
  }

  PermissionQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PermissionQuery>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PermissionQuery& from);
  void MergeFrom(const PermissionQuery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionQuery* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.PermissionQuery";
  }
  protected:
  explicit PermissionQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kPermissionsFieldNumber = 2,
    kFlushFieldNumber = 3,
  };
  // optional uint32 channel_id = 1;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id() const;
  void set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id() const;
  void _internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 permissions = 2;
  bool has_permissions() const;
  private:
  bool _internal_has_permissions() const;
  public:
  void clear_permissions();
  ::PROTOBUF_NAMESPACE_ID::uint32 permissions() const;
  void set_permissions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_permissions() const;
  void _internal_set_permissions(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool flush = 3 [default = false];
  bool has_flush() const;
  private:
  bool _internal_has_flush() const;
  public:
  void clear_flush();
  bool flush() const;
  void set_flush(bool value);
  private:
  bool _internal_flush() const;
  void _internal_set_flush(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.PermissionQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 permissions_;
  bool flush_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class CodecVersion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.CodecVersion) */ {
 public:
  inline CodecVersion() : CodecVersion(nullptr) {};
  virtual ~CodecVersion();

  CodecVersion(const CodecVersion& from);
  CodecVersion(CodecVersion&& from) noexcept
    : CodecVersion() {
    *this = ::std::move(from);
  }

  inline CodecVersion& operator=(const CodecVersion& from) {
    CopyFrom(from);
    return *this;
  }
  inline CodecVersion& operator=(CodecVersion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CodecVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CodecVersion* internal_default_instance() {
    return reinterpret_cast<const CodecVersion*>(
               &_CodecVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CodecVersion& a, CodecVersion& b) {
    a.Swap(&b);
  }
  inline void Swap(CodecVersion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CodecVersion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CodecVersion* New() const final {
    return CreateMaybeMessage<CodecVersion>(nullptr);
  }

  CodecVersion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CodecVersion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CodecVersion& from);
  void MergeFrom(const CodecVersion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodecVersion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.CodecVersion";
  }
  protected:
  explicit CodecVersion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlphaFieldNumber = 1,
    kBetaFieldNumber = 2,
    kOpusFieldNumber = 4,
    kPreferAlphaFieldNumber = 3,
  };
  // required int32 alpha = 1;
  bool has_alpha() const;
  private:
  bool _internal_has_alpha() const;
  public:
  void clear_alpha();
  ::PROTOBUF_NAMESPACE_ID::int32 alpha() const;
  void set_alpha(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_alpha() const;
  void _internal_set_alpha(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 beta = 2;
  bool has_beta() const;
  private:
  bool _internal_has_beta() const;
  public:
  void clear_beta();
  ::PROTOBUF_NAMESPACE_ID::int32 beta() const;
  void set_beta(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_beta() const;
  void _internal_set_beta(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool opus = 4 [default = false];
  bool has_opus() const;
  private:
  bool _internal_has_opus() const;
  public:
  void clear_opus();
  bool opus() const;
  void set_opus(bool value);
  private:
  bool _internal_opus() const;
  void _internal_set_opus(bool value);
  public:

  // required bool prefer_alpha = 3 [default = true];
  bool has_prefer_alpha() const;
  private:
  bool _internal_has_prefer_alpha() const;
  public:
  void clear_prefer_alpha();
  bool prefer_alpha() const;
  void set_prefer_alpha(bool value);
  private:
  bool _internal_prefer_alpha() const;
  void _internal_set_prefer_alpha(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.CodecVersion)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 alpha_;
  ::PROTOBUF_NAMESPACE_ID::int32 beta_;
  bool opus_;
  bool prefer_alpha_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserStats_Stats PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserStats.Stats) */ {
 public:
  inline UserStats_Stats() : UserStats_Stats(nullptr) {};
  virtual ~UserStats_Stats();

  UserStats_Stats(const UserStats_Stats& from);
  UserStats_Stats(UserStats_Stats&& from) noexcept
    : UserStats_Stats() {
    *this = ::std::move(from);
  }

  inline UserStats_Stats& operator=(const UserStats_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStats_Stats& operator=(UserStats_Stats&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserStats_Stats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserStats_Stats* internal_default_instance() {
    return reinterpret_cast<const UserStats_Stats*>(
               &_UserStats_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UserStats_Stats& a, UserStats_Stats& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStats_Stats* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStats_Stats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserStats_Stats* New() const final {
    return CreateMaybeMessage<UserStats_Stats>(nullptr);
  }

  UserStats_Stats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserStats_Stats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserStats_Stats& from);
  void MergeFrom(const UserStats_Stats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserStats_Stats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.UserStats.Stats";
  }
  protected:
  explicit UserStats_Stats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGoodFieldNumber = 1,
    kLateFieldNumber = 2,
    kLostFieldNumber = 3,
    kResyncFieldNumber = 4,
  };
  // optional uint32 good = 1;
  bool has_good() const;
  private:
  bool _internal_has_good() const;
  public:
  void clear_good();
  ::PROTOBUF_NAMESPACE_ID::uint32 good() const;
  void set_good(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_good() const;
  void _internal_set_good(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 late = 2;
  bool has_late() const;
  private:
  bool _internal_has_late() const;
  public:
  void clear_late();
  ::PROTOBUF_NAMESPACE_ID::uint32 late() const;
  void set_late(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_late() const;
  void _internal_set_late(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 lost = 3;
  bool has_lost() const;
  private:
  bool _internal_has_lost() const;
  public:
  void clear_lost();
  ::PROTOBUF_NAMESPACE_ID::uint32 lost() const;
  void set_lost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lost() const;
  void _internal_set_lost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 resync = 4;
  bool has_resync() const;
  private:
  bool _internal_has_resync() const;
  public:
  void clear_resync();
  ::PROTOBUF_NAMESPACE_ID::uint32 resync() const;
  void set_resync(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_resync() const;
  void _internal_set_resync(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.UserStats.Stats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 good_;
  ::PROTOBUF_NAMESPACE_ID::uint32 late_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lost_;
  ::PROTOBUF_NAMESPACE_ID::uint32 resync_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserStats PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserStats) */ {
 public:
  inline UserStats() : UserStats(nullptr) {};
  virtual ~UserStats();

  UserStats(const UserStats& from);
  UserStats(UserStats&& from) noexcept
    : UserStats() {
    *this = ::std::move(from);
  }

  inline UserStats& operator=(const UserStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStats& operator=(UserStats&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserStats* internal_default_instance() {
    return reinterpret_cast<const UserStats*>(
               &_UserStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UserStats& a, UserStats& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStats* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserStats* New() const final {
    return CreateMaybeMessage<UserStats>(nullptr);
  }

  UserStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserStats& from);
  void MergeFrom(const UserStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.UserStats";
  }
  protected:
  explicit UserStats(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UserStats_Stats Stats;

  // accessors -------------------------------------------------------

  enum : int {
    kCertificatesFieldNumber = 3,
    kCeltVersionsFieldNumber = 13,
    kAddressFieldNumber = 14,
    kFromClientFieldNumber = 4,
    kFromServerFieldNumber = 5,
    kVersionFieldNumber = 12,
    kSessionFieldNumber = 1,
    kUdpPacketsFieldNumber = 6,
    kTcpPacketsFieldNumber = 7,
    kUdpPingAvgFieldNumber = 8,
    kUdpPingVarFieldNumber = 9,
    kTcpPingAvgFieldNumber = 10,
    kTcpPingVarFieldNumber = 11,
    kStatsOnlyFieldNumber = 2,
    kStrongCertificateFieldNumber = 18,
    kOpusFieldNumber = 19,
    kBandwidthFieldNumber = 15,
    kOnlinesecsFieldNumber = 16,
    kIdlesecsFieldNumber = 17,
  };
  // repeated bytes certificates = 3;
  int certificates_size() const;
  private:
  int _internal_certificates_size() const;
  public:
  void clear_certificates();
  const std::string& certificates(int index) const;
  std::string* mutable_certificates(int index);
  void set_certificates(int index, const std::string& value);
  void set_certificates(int index, std::string&& value);
  void set_certificates(int index, const char* value);
  void set_certificates(int index, const void* value, size_t size);
  std::string* add_certificates();
  void add_certificates(const std::string& value);
  void add_certificates(std::string&& value);
  void add_certificates(const char* value);
  void add_certificates(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& certificates() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_certificates();
  private:
  const std::string& _internal_certificates(int index) const;
  std::string* _internal_add_certificates();
  public:

  // repeated int32 celt_versions = 13;
  int celt_versions_size() const;
  private:
  int _internal_celt_versions_size() const;
  public:
  void clear_celt_versions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_celt_versions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_celt_versions() const;
  void _internal_add_celt_versions(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_celt_versions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 celt_versions(int index) const;
  void set_celt_versions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_celt_versions(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      celt_versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_celt_versions();

  // optional bytes address = 14;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional .MumbleProto.UserStats.Stats from_client = 4;
  bool has_from_client() const;
  private:
  bool _internal_has_from_client() const;
  public:
  void clear_from_client();
  const ::MumbleProto::UserStats_Stats& from_client() const;
  ::MumbleProto::UserStats_Stats* release_from_client();
  ::MumbleProto::UserStats_Stats* mutable_from_client();
  void set_allocated_from_client(::MumbleProto::UserStats_Stats* from_client);
  private:
  const ::MumbleProto::UserStats_Stats& _internal_from_client() const;
  ::MumbleProto::UserStats_Stats* _internal_mutable_from_client();
  public:
  void unsafe_arena_set_allocated_from_client(
      ::MumbleProto::UserStats_Stats* from_client);
  ::MumbleProto::UserStats_Stats* unsafe_arena_release_from_client();

  // optional .MumbleProto.UserStats.Stats from_server = 5;
  bool has_from_server() const;
  private:
  bool _internal_has_from_server() const;
  public:
  void clear_from_server();
  const ::MumbleProto::UserStats_Stats& from_server() const;
  ::MumbleProto::UserStats_Stats* release_from_server();
  ::MumbleProto::UserStats_Stats* mutable_from_server();
  void set_allocated_from_server(::MumbleProto::UserStats_Stats* from_server);
  private:
  const ::MumbleProto::UserStats_Stats& _internal_from_server() const;
  ::MumbleProto::UserStats_Stats* _internal_mutable_from_server();
  public:
  void unsafe_arena_set_allocated_from_server(
      ::MumbleProto::UserStats_Stats* from_server);
  ::MumbleProto::UserStats_Stats* unsafe_arena_release_from_server();

  // optional .MumbleProto.Version version = 12;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::MumbleProto::Version& version() const;
  ::MumbleProto::Version* release_version();
  ::MumbleProto::Version* mutable_version();
  void set_allocated_version(::MumbleProto::Version* version);
  private:
  const ::MumbleProto::Version& _internal_version() const;
  ::MumbleProto::Version* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::MumbleProto::Version* version);
  ::MumbleProto::Version* unsafe_arena_release_version();

  // optional uint32 session = 1;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::uint32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 udp_packets = 6;
  bool has_udp_packets() const;
  private:
  bool _internal_has_udp_packets() const;
  public:
  void clear_udp_packets();
  ::PROTOBUF_NAMESPACE_ID::uint32 udp_packets() const;
  void set_udp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_udp_packets() const;
  void _internal_set_udp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 tcp_packets = 7;
  bool has_tcp_packets() const;
  private:
  bool _internal_has_tcp_packets() const;
  public:
  void clear_tcp_packets();
  ::PROTOBUF_NAMESPACE_ID::uint32 tcp_packets() const;
  void set_tcp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tcp_packets() const;
  void _internal_set_tcp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float udp_ping_avg = 8;
  bool has_udp_ping_avg() const;
  private:
  bool _internal_has_udp_ping_avg() const;
  public:
  void clear_udp_ping_avg();
  float udp_ping_avg() const;
  void set_udp_ping_avg(float value);
  private:
  float _internal_udp_ping_avg() const;
  void _internal_set_udp_ping_avg(float value);
  public:

  // optional float udp_ping_var = 9;
  bool has_udp_ping_var() const;
  private:
  bool _internal_has_udp_ping_var() const;
  public:
  void clear_udp_ping_var();
  float udp_ping_var() const;
  void set_udp_ping_var(float value);
  private:
  float _internal_udp_ping_var() const;
  void _internal_set_udp_ping_var(float value);
  public:

  // optional float tcp_ping_avg = 10;
  bool has_tcp_ping_avg() const;
  private:
  bool _internal_has_tcp_ping_avg() const;
  public:
  void clear_tcp_ping_avg();
  float tcp_ping_avg() const;
  void set_tcp_ping_avg(float value);
  private:
  float _internal_tcp_ping_avg() const;
  void _internal_set_tcp_ping_avg(float value);
  public:

  // optional float tcp_ping_var = 11;
  bool has_tcp_ping_var() const;
  private:
  bool _internal_has_tcp_ping_var() const;
  public:
  void clear_tcp_ping_var();
  float tcp_ping_var() const;
  void set_tcp_ping_var(float value);
  private:
  float _internal_tcp_ping_var() const;
  void _internal_set_tcp_ping_var(float value);
  public:

  // optional bool stats_only = 2 [default = false];
  bool has_stats_only() const;
  private:
  bool _internal_has_stats_only() const;
  public:
  void clear_stats_only();
  bool stats_only() const;
  void set_stats_only(bool value);
  private:
  bool _internal_stats_only() const;
  void _internal_set_stats_only(bool value);
  public:

  // optional bool strong_certificate = 18 [default = false];
  bool has_strong_certificate() const;
  private:
  bool _internal_has_strong_certificate() const;
  public:
  void clear_strong_certificate();
  bool strong_certificate() const;
  void set_strong_certificate(bool value);
  private:
  bool _internal_strong_certificate() const;
  void _internal_set_strong_certificate(bool value);
  public:

  // optional bool opus = 19 [default = false];
  bool has_opus() const;
  private:
  bool _internal_has_opus() const;
  public:
  void clear_opus();
  bool opus() const;
  void set_opus(bool value);
  private:
  bool _internal_opus() const;
  void _internal_set_opus(bool value);
  public:

  // optional uint32 bandwidth = 15;
  bool has_bandwidth() const;
  private:
  bool _internal_has_bandwidth() const;
  public:
  void clear_bandwidth();
  ::PROTOBUF_NAMESPACE_ID::uint32 bandwidth() const;
  void set_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_bandwidth() const;
  void _internal_set_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 onlinesecs = 16;
  bool has_onlinesecs() const;
  private:
  bool _internal_has_onlinesecs() const;
  public:
  void clear_onlinesecs();
  ::PROTOBUF_NAMESPACE_ID::uint32 onlinesecs() const;
  void set_onlinesecs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_onlinesecs() const;
  void _internal_set_onlinesecs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 idlesecs = 17;
  bool has_idlesecs() const;
  private:
  bool _internal_has_idlesecs() const;
  public:
  void clear_idlesecs();
  ::PROTOBUF_NAMESPACE_ID::uint32 idlesecs() const;
  void set_idlesecs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idlesecs() const;
  void _internal_set_idlesecs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.UserStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> certificates_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > celt_versions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::MumbleProto::UserStats_Stats* from_client_;
  ::MumbleProto::UserStats_Stats* from_server_;
  ::MumbleProto::Version* version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_;
  ::PROTOBUF_NAMESPACE_ID::uint32 udp_packets_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tcp_packets_;
  float udp_ping_avg_;
  float udp_ping_var_;
  float tcp_ping_avg_;
  float tcp_ping_var_;
  bool stats_only_;
  bool strong_certificate_;
  bool opus_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bandwidth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 onlinesecs_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idlesecs_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class RequestBlob PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.RequestBlob) */ {
 public:
  inline RequestBlob() : RequestBlob(nullptr) {};
  virtual ~RequestBlob();

  RequestBlob(const RequestBlob& from);
  RequestBlob(RequestBlob&& from) noexcept
    : RequestBlob() {
    *this = ::std::move(from);
  }

  inline RequestBlob& operator=(const RequestBlob& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestBlob& operator=(RequestBlob&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RequestBlob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestBlob* internal_default_instance() {
    return reinterpret_cast<const RequestBlob*>(
               &_RequestBlob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RequestBlob& a, RequestBlob& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestBlob* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestBlob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestBlob* New() const final {
    return CreateMaybeMessage<RequestBlob>(nullptr);
  }

  RequestBlob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestBlob>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RequestBlob& from);
  void MergeFrom(const RequestBlob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBlob* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.RequestBlob";
  }
  protected:
  explicit RequestBlob(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionTextureFieldNumber = 1,
    kSessionCommentFieldNumber = 2,
    kChannelDescriptionFieldNumber = 3,
  };
  // repeated uint32 session_texture = 1;
  int session_texture_size() const;
  private:
  int _internal_session_texture_size() const;
  public:
  void clear_session_texture();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session_texture(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_session_texture() const;
  void _internal_add_session_texture(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_session_texture();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 session_texture(int index) const;
  void set_session_texture(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_session_texture(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      session_texture() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_session_texture();

  // repeated uint32 session_comment = 2;
  int session_comment_size() const;
  private:
  int _internal_session_comment_size() const;
  public:
  void clear_session_comment();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session_comment(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_session_comment() const;
  void _internal_add_session_comment(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_session_comment();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 session_comment(int index) const;
  void set_session_comment(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_session_comment(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      session_comment() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_session_comment();

  // repeated uint32 channel_description = 3;
  int channel_description_size() const;
  private:
  int _internal_channel_description_size() const;
  public:
  void clear_channel_description();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_description(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_channel_description() const;
  void _internal_add_channel_description(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_channel_description();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_description(int index) const;
  void set_channel_description(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_channel_description(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      channel_description() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_channel_description();

  // @@protoc_insertion_point(class_scope:MumbleProto.RequestBlob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > session_texture_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > session_comment_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > channel_description_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ServerConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ServerConfig) */ {
 public:
  inline ServerConfig() : ServerConfig(nullptr) {};
  virtual ~ServerConfig();

  ServerConfig(const ServerConfig& from);
  ServerConfig(ServerConfig&& from) noexcept
    : ServerConfig() {
    *this = ::std::move(from);
  }

  inline ServerConfig& operator=(const ServerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerConfig& operator=(ServerConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerConfig* internal_default_instance() {
    return reinterpret_cast<const ServerConfig*>(
               &_ServerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ServerConfig& a, ServerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerConfig* New() const final {
    return CreateMaybeMessage<ServerConfig>(nullptr);
  }

  ServerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerConfig& from);
  void MergeFrom(const ServerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.ServerConfig";
  }
  protected:
  explicit ServerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWelcomeTextFieldNumber = 2,
    kMaxBandwidthFieldNumber = 1,
    kAllowHtmlFieldNumber = 3,
    kMessageLengthFieldNumber = 4,
    kImageMessageLengthFieldNumber = 5,
    kMaxUsersFieldNumber = 6,
  };
  // optional string welcome_text = 2;
  bool has_welcome_text() const;
  private:
  bool _internal_has_welcome_text() const;
  public:
  void clear_welcome_text();
  const std::string& welcome_text() const;
  void set_welcome_text(const std::string& value);
  void set_welcome_text(std::string&& value);
  void set_welcome_text(const char* value);
  void set_welcome_text(const char* value, size_t size);
  std::string* mutable_welcome_text();
  std::string* release_welcome_text();
  void set_allocated_welcome_text(std::string* welcome_text);
  private:
  const std::string& _internal_welcome_text() const;
  void _internal_set_welcome_text(const std::string& value);
  std::string* _internal_mutable_welcome_text();
  public:

  // optional uint32 max_bandwidth = 1;
  bool has_max_bandwidth() const;
  private:
  bool _internal_has_max_bandwidth() const;
  public:
  void clear_max_bandwidth();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_bandwidth() const;
  void set_max_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_bandwidth() const;
  void _internal_set_max_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool allow_html = 3;
  bool has_allow_html() const;
  private:
  bool _internal_has_allow_html() const;
  public:
  void clear_allow_html();
  bool allow_html() const;
  void set_allow_html(bool value);
  private:
  bool _internal_allow_html() const;
  void _internal_set_allow_html(bool value);
  public:

  // optional uint32 message_length = 4;
  bool has_message_length() const;
  private:
  bool _internal_has_message_length() const;
  public:
  void clear_message_length();
  ::PROTOBUF_NAMESPACE_ID::uint32 message_length() const;
  void set_message_length(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_message_length() const;
  void _internal_set_message_length(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 image_message_length = 5;
  bool has_image_message_length() const;
  private:
  bool _internal_has_image_message_length() const;
  public:
  void clear_image_message_length();
  ::PROTOBUF_NAMESPACE_ID::uint32 image_message_length() const;
  void set_image_message_length(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_image_message_length() const;
  void _internal_set_image_message_length(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 max_users = 6;
  bool has_max_users() const;
  private:
  bool _internal_has_max_users() const;
  public:
  void clear_max_users();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_users() const;
  void set_max_users(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_users() const;
  void _internal_set_max_users(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.ServerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr welcome_text_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_bandwidth_;
  bool allow_html_;
  ::PROTOBUF_NAMESPACE_ID::uint32 message_length_;
  ::PROTOBUF_NAMESPACE_ID::uint32 image_message_length_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_users_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class SuggestConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MumbleProto.SuggestConfig) */ {
 public:
  inline SuggestConfig() : SuggestConfig(nullptr) {};
  virtual ~SuggestConfig();

  SuggestConfig(const SuggestConfig& from);
  SuggestConfig(SuggestConfig&& from) noexcept
    : SuggestConfig() {
    *this = ::std::move(from);
  }

  inline SuggestConfig& operator=(const SuggestConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SuggestConfig& operator=(SuggestConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SuggestConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SuggestConfig* internal_default_instance() {
    return reinterpret_cast<const SuggestConfig*>(
               &_SuggestConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(SuggestConfig& a, SuggestConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SuggestConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SuggestConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SuggestConfig* New() const final {
    return CreateMaybeMessage<SuggestConfig>(nullptr);
  }

  SuggestConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SuggestConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SuggestConfig& from);
  void MergeFrom(const SuggestConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuggestConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MumbleProto.SuggestConfig";
  }
  protected:
  explicit SuggestConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Mumble_2eproto);
    return ::descriptor_table_Mumble_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kPositionalFieldNumber = 2,
    kPushToTalkFieldNumber = 3,
  };
  // optional uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool positional = 2;
  bool has_positional() const;
  private:
  bool _internal_has_positional() const;
  public:
  void clear_positional();
  bool positional() const;
  void set_positional(bool value);
  private:
  bool _internal_positional() const;
  void _internal_set_positional(bool value);
  public:

  // optional bool push_to_talk = 3;
  bool has_push_to_talk() const;
  private:
  bool _internal_has_push_to_talk() const;
  public:
  void clear_push_to_talk();
  bool push_to_talk() const;
  void set_push_to_talk(bool value);
  private:
  bool _internal_push_to_talk() const;
  void _internal_set_push_to_talk(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MumbleProto.SuggestConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  bool positional_;
  bool push_to_talk_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// optional uint32 version = 1;
inline bool Version::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Version::has_version() const {
  return _internal_has_version();
}
inline void Version::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Version::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Version::version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.version)
  return _internal_version();
}
inline void Version::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  version_ = value;
}
inline void Version::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.version)
}

// optional string release = 2;
inline bool Version::_internal_has_release() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Version::has_release() const {
  return _internal_has_release();
}
inline void Version::clear_release() {
  release_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Version::release() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.release)
  return _internal_release();
}
inline void Version::set_release(const std::string& value) {
  _internal_set_release(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.release)
}
inline std::string* Version::mutable_release() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.Version.release)
  return _internal_mutable_release();
}
inline const std::string& Version::_internal_release() const {
  return release_.Get();
}
inline void Version::_internal_set_release(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  release_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Version::set_release(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  release_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Version.release)
}
inline void Version::set_release(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  release_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.Version.release)
}
inline void Version::set_release(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  release_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.release)
}
inline std::string* Version::_internal_mutable_release() {
  _has_bits_[0] |= 0x00000001u;
  return release_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Version::release_release() {
  // @@protoc_insertion_point(field_release:MumbleProto.Version.release)
  if (!_internal_has_release()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return release_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Version::set_allocated_release(std::string* release) {
  if (release != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  release_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), release,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.release)
}

// optional string os = 3;
inline bool Version::_internal_has_os() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Version::has_os() const {
  return _internal_has_os();
}
inline void Version::clear_os() {
  os_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Version::os() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.os)
  return _internal_os();
}
inline void Version::set_os(const std::string& value) {
  _internal_set_os(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.os)
}
inline std::string* Version::mutable_os() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.Version.os)
  return _internal_mutable_os();
}
inline const std::string& Version::_internal_os() const {
  return os_.Get();
}
inline void Version::_internal_set_os(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  os_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Version::set_os(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  os_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Version.os)
}
inline void Version::set_os(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  os_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.Version.os)
}
inline void Version::set_os(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  os_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.os)
}
inline std::string* Version::_internal_mutable_os() {
  _has_bits_[0] |= 0x00000002u;
  return os_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Version::release_os() {
  // @@protoc_insertion_point(field_release:MumbleProto.Version.os)
  if (!_internal_has_os()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return os_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Version::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  os_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.os)
}

// optional string os_version = 4;
inline bool Version::_internal_has_os_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Version::has_os_version() const {
  return _internal_has_os_version();
}
inline void Version::clear_os_version() {
  os_version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Version::os_version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.os_version)
  return _internal_os_version();
}
inline void Version::set_os_version(const std::string& value) {
  _internal_set_os_version(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.os_version)
}
inline std::string* Version::mutable_os_version() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.Version.os_version)
  return _internal_mutable_os_version();
}
inline const std::string& Version::_internal_os_version() const {
  return os_version_.Get();
}
inline void Version::_internal_set_os_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  os_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Version::set_os_version(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  os_version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Version.os_version)
}
inline void Version::set_os_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  os_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.Version.os_version)
}
inline void Version::set_os_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  os_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.os_version)
}
inline std::string* Version::_internal_mutable_os_version() {
  _has_bits_[0] |= 0x00000004u;
  return os_version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Version::release_os_version() {
  // @@protoc_insertion_point(field_release:MumbleProto.Version.os_version)
  if (!_internal_has_os_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return os_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Version::set_allocated_os_version(std::string* os_version) {
  if (os_version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  os_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os_version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.os_version)
}

// -------------------------------------------------------------------

// UDPTunnel

// required bytes packet = 1;
inline bool UDPTunnel::_internal_has_packet() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UDPTunnel::has_packet() const {
  return _internal_has_packet();
}
inline void UDPTunnel::clear_packet() {
  packet_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UDPTunnel::packet() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UDPTunnel.packet)
  return _internal_packet();
}
inline void UDPTunnel::set_packet(const std::string& value) {
  _internal_set_packet(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UDPTunnel.packet)
}
inline std::string* UDPTunnel::mutable_packet() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UDPTunnel.packet)
  return _internal_mutable_packet();
}
inline const std::string& UDPTunnel::_internal_packet() const {
  return packet_.Get();
}
inline void UDPTunnel::_internal_set_packet(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  packet_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UDPTunnel::set_packet(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  packet_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UDPTunnel.packet)
}
inline void UDPTunnel::set_packet(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  packet_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UDPTunnel.packet)
}
inline void UDPTunnel::set_packet(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  packet_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UDPTunnel.packet)
}
inline std::string* UDPTunnel::_internal_mutable_packet() {
  _has_bits_[0] |= 0x00000001u;
  return packet_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UDPTunnel::release_packet() {
  // @@protoc_insertion_point(field_release:MumbleProto.UDPTunnel.packet)
  if (!_internal_has_packet()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return packet_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UDPTunnel::set_allocated_packet(std::string* packet) {
  if (packet != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  packet_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), packet,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UDPTunnel.packet)
}

// -------------------------------------------------------------------

// Authenticate

// optional string username = 1;
inline bool Authenticate::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Authenticate::has_username() const {
  return _internal_has_username();
}
inline void Authenticate::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Authenticate::username() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.username)
  return _internal_username();
}
inline void Authenticate::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.username)
}
inline std::string* Authenticate::mutable_username() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.username)
  return _internal_mutable_username();
}
inline const std::string& Authenticate::_internal_username() const {
  return username_.Get();
}
inline void Authenticate::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Authenticate::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Authenticate.username)
}
inline void Authenticate::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.username)
}
inline void Authenticate::set_username(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.username)
}
inline std::string* Authenticate::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Authenticate::release_username() {
  // @@protoc_insertion_point(field_release:MumbleProto.Authenticate.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Authenticate::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Authenticate.username)
}

// optional string password = 2;
inline bool Authenticate::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Authenticate::has_password() const {
  return _internal_has_password();
}
inline void Authenticate::clear_password() {
  password_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Authenticate::password() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.password)
  return _internal_password();
}
inline void Authenticate::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.password)
}
inline std::string* Authenticate::mutable_password() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.password)
  return _internal_mutable_password();
}
inline const std::string& Authenticate::_internal_password() const {
  return password_.Get();
}
inline void Authenticate::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Authenticate::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Authenticate.password)
}
inline void Authenticate::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.password)
}
inline void Authenticate::set_password(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.password)
}
inline std::string* Authenticate::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Authenticate::release_password() {
  // @@protoc_insertion_point(field_release:MumbleProto.Authenticate.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Authenticate::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Authenticate.password)
}

// repeated string tokens = 3;
inline int Authenticate::_internal_tokens_size() const {
  return tokens_.size();
}
inline int Authenticate::tokens_size() const {
  return _internal_tokens_size();
}
inline void Authenticate::clear_tokens() {
  tokens_.Clear();
}
inline std::string* Authenticate::add_tokens() {
  // @@protoc_insertion_point(field_add_mutable:MumbleProto.Authenticate.tokens)
  return _internal_add_tokens();
}
inline const std::string& Authenticate::_internal_tokens(int index) const {
  return tokens_.Get(index);
}
inline const std::string& Authenticate::tokens(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.tokens)
  return _internal_tokens(index);
}
inline std::string* Authenticate::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.tokens)
  return tokens_.Mutable(index);
}
inline void Authenticate::set_tokens(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.tokens)
  tokens_.Mutable(index)->assign(value);
}
inline void Authenticate::set_tokens(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.tokens)
  tokens_.Mutable(index)->assign(std::move(value));
}
inline void Authenticate::set_tokens(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.tokens)
}
inline void Authenticate::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.tokens)
}
inline std::string* Authenticate::_internal_add_tokens() {
  return tokens_.Add();
}
inline void Authenticate::add_tokens(const std::string& value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.tokens)
}
inline void Authenticate::add_tokens(std::string&& value) {
  tokens_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.tokens)
}
inline void Authenticate::add_tokens(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MumbleProto.Authenticate.tokens)
}
inline void Authenticate::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MumbleProto.Authenticate.tokens)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Authenticate::tokens() const {
  // @@protoc_insertion_point(field_list:MumbleProto.Authenticate.tokens)
  return tokens_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Authenticate::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.Authenticate.tokens)
  return &tokens_;
}

// repeated int32 celt_versions = 4;
inline int Authenticate::_internal_celt_versions_size() const {
  return celt_versions_.size();
}
inline int Authenticate::celt_versions_size() const {
  return _internal_celt_versions_size();
}
inline void Authenticate::clear_celt_versions() {
  celt_versions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Authenticate::_internal_celt_versions(int index) const {
  return celt_versions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Authenticate::celt_versions(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.celt_versions)
  return _internal_celt_versions(index);
}
inline void Authenticate::set_celt_versions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  celt_versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.celt_versions)
}
inline void Authenticate::_internal_add_celt_versions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  celt_versions_.Add(value);
}
inline void Authenticate::add_celt_versions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_celt_versions(value);
  // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.celt_versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Authenticate::_internal_celt_versions() const {
  return celt_versions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
Authenticate::celt_versions() const {
  // @@protoc_insertion_point(field_list:MumbleProto.Authenticate.celt_versions)
  return _internal_celt_versions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Authenticate::_internal_mutable_celt_versions() {
  return &celt_versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
Authenticate::mutable_celt_versions() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.Authenticate.celt_versions)
  return _internal_mutable_celt_versions();
}

// optional bool opus = 5 [default = false];
inline bool Authenticate::_internal_has_opus() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Authenticate::has_opus() const {
  return _internal_has_opus();
}
inline void Authenticate::clear_opus() {
  opus_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Authenticate::_internal_opus() const {
  return opus_;
}
inline bool Authenticate::opus() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.opus)
  return _internal_opus();
}
inline void Authenticate::_internal_set_opus(bool value) {
  _has_bits_[0] |= 0x00000004u;
  opus_ = value;
}
inline void Authenticate::set_opus(bool value) {
  _internal_set_opus(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.opus)
}

// -------------------------------------------------------------------

// Ping

// optional uint64 timestamp = 1;
inline bool Ping::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ping::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Ping::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ping::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.timestamp)
  return _internal_timestamp();
}
inline void Ping::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
}
inline void Ping::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.timestamp)
}

// optional uint32 good = 2;
inline bool Ping::_internal_has_good() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ping::has_good() const {
  return _internal_has_good();
}
inline void Ping::clear_good() {
  good_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::_internal_good() const {
  return good_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::good() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.good)
  return _internal_good();
}
inline void Ping::_internal_set_good(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  good_ = value;
}
inline void Ping::set_good(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_good(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.good)
}

// optional uint32 late = 3;
inline bool Ping::_internal_has_late() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Ping::has_late() const {
  return _internal_has_late();
}
inline void Ping::clear_late() {
  late_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::_internal_late() const {
  return late_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::late() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.late)
  return _internal_late();
}
inline void Ping::_internal_set_late(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  late_ = value;
}
inline void Ping::set_late(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_late(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.late)
}

// optional uint32 lost = 4;
inline bool Ping::_internal_has_lost() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Ping::has_lost() const {
  return _internal_has_lost();
}
inline void Ping::clear_lost() {
  lost_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::_internal_lost() const {
  return lost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::lost() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.lost)
  return _internal_lost();
}
inline void Ping::_internal_set_lost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  lost_ = value;
}
inline void Ping::set_lost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lost(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.lost)
}

// optional uint32 resync = 5;
inline bool Ping::_internal_has_resync() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Ping::has_resync() const {
  return _internal_has_resync();
}
inline void Ping::clear_resync() {
  resync_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::_internal_resync() const {
  return resync_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::resync() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.resync)
  return _internal_resync();
}
inline void Ping::_internal_set_resync(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  resync_ = value;
}
inline void Ping::set_resync(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_resync(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.resync)
}

// optional uint32 udp_packets = 6;
inline bool Ping::_internal_has_udp_packets() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Ping::has_udp_packets() const {
  return _internal_has_udp_packets();
}
inline void Ping::clear_udp_packets() {
  udp_packets_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::_internal_udp_packets() const {
  return udp_packets_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::udp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_packets)
  return _internal_udp_packets();
}
inline void Ping::_internal_set_udp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  udp_packets_ = value;
}
inline void Ping::set_udp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_udp_packets(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_packets)
}

// optional uint32 tcp_packets = 7;
inline bool Ping::_internal_has_tcp_packets() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Ping::has_tcp_packets() const {
  return _internal_has_tcp_packets();
}
inline void Ping::clear_tcp_packets() {
  tcp_packets_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::_internal_tcp_packets() const {
  return tcp_packets_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::tcp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_packets)
  return _internal_tcp_packets();
}
inline void Ping::_internal_set_tcp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  tcp_packets_ = value;
}
inline void Ping::set_tcp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tcp_packets(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_packets)
}

// optional float udp_ping_avg = 8;
inline bool Ping::_internal_has_udp_ping_avg() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Ping::has_udp_ping_avg() const {
  return _internal_has_udp_ping_avg();
}
inline void Ping::clear_udp_ping_avg() {
  udp_ping_avg_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Ping::_internal_udp_ping_avg() const {
  return udp_ping_avg_;
}
inline float Ping::udp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_ping_avg)
  return _internal_udp_ping_avg();
}
inline void Ping::_internal_set_udp_ping_avg(float value) {
  _has_bits_[0] |= 0x00000080u;
  udp_ping_avg_ = value;
}
inline void Ping::set_udp_ping_avg(float value) {
  _internal_set_udp_ping_avg(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_ping_avg)
}

// optional float udp_ping_var = 9;
inline bool Ping::_internal_has_udp_ping_var() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Ping::has_udp_ping_var() const {
  return _internal_has_udp_ping_var();
}
inline void Ping::clear_udp_ping_var() {
  udp_ping_var_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Ping::_internal_udp_ping_var() const {
  return udp_ping_var_;
}
inline float Ping::udp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_ping_var)
  return _internal_udp_ping_var();
}
inline void Ping::_internal_set_udp_ping_var(float value) {
  _has_bits_[0] |= 0x00000100u;
  udp_ping_var_ = value;
}
inline void Ping::set_udp_ping_var(float value) {
  _internal_set_udp_ping_var(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_ping_var)
}

// optional float tcp_ping_avg = 10;
inline bool Ping::_internal_has_tcp_ping_avg() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Ping::has_tcp_ping_avg() const {
  return _internal_has_tcp_ping_avg();
}
inline void Ping::clear_tcp_ping_avg() {
  tcp_ping_avg_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Ping::_internal_tcp_ping_avg() const {
  return tcp_ping_avg_;
}
inline float Ping::tcp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_ping_avg)
  return _internal_tcp_ping_avg();
}
inline void Ping::_internal_set_tcp_ping_avg(float value) {
  _has_bits_[0] |= 0x00000200u;
  tcp_ping_avg_ = value;
}
inline void Ping::set_tcp_ping_avg(float value) {
  _internal_set_tcp_ping_avg(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_ping_avg)
}

// optional float tcp_ping_var = 11;
inline bool Ping::_internal_has_tcp_ping_var() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Ping::has_tcp_ping_var() const {
  return _internal_has_tcp_ping_var();
}
inline void Ping::clear_tcp_ping_var() {
  tcp_ping_var_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float Ping::_internal_tcp_ping_var() const {
  return tcp_ping_var_;
}
inline float Ping::tcp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_ping_var)
  return _internal_tcp_ping_var();
}
inline void Ping::_internal_set_tcp_ping_var(float value) {
  _has_bits_[0] |= 0x00000400u;
  tcp_ping_var_ = value;
}
inline void Ping::set_tcp_ping_var(float value) {
  _internal_set_tcp_ping_var(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_ping_var)
}

// -------------------------------------------------------------------

// Reject

// optional .MumbleProto.Reject.RejectType type = 1;
inline bool Reject::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Reject::has_type() const {
  return _internal_has_type();
}
inline void Reject::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::MumbleProto::Reject_RejectType Reject::_internal_type() const {
  return static_cast< ::MumbleProto::Reject_RejectType >(type_);
}
inline ::MumbleProto::Reject_RejectType Reject::type() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Reject.type)
  return _internal_type();
}
inline void Reject::_internal_set_type(::MumbleProto::Reject_RejectType value) {
  assert(::MumbleProto::Reject_RejectType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void Reject::set_type(::MumbleProto::Reject_RejectType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Reject.type)
}

// optional string reason = 2;
inline bool Reject::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Reject::has_reason() const {
  return _internal_has_reason();
}
inline void Reject::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Reject::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Reject.reason)
  return _internal_reason();
}
inline void Reject::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:MumbleProto.Reject.reason)
}
inline std::string* Reject::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.Reject.reason)
  return _internal_mutable_reason();
}
inline const std::string& Reject::_internal_reason() const {
  return reason_.Get();
}
inline void Reject::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Reject::set_reason(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Reject.reason)
}
inline void Reject::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.Reject.reason)
}
inline void Reject::set_reason(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Reject.reason)
}
inline std::string* Reject::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Reject::release_reason() {
  // @@protoc_insertion_point(field_release:MumbleProto.Reject.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Reject::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Reject.reason)
}

// -------------------------------------------------------------------

// ServerSync

// optional uint32 session = 1;
inline bool ServerSync::_internal_has_session() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ServerSync::has_session() const {
  return _internal_has_session();
}
inline void ServerSync::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerSync::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerSync::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.session)
  return _internal_session();
}
inline void ServerSync::_internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  session_ = value;
}
inline void ServerSync::set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.session)
}

// optional uint32 max_bandwidth = 2;
inline bool ServerSync::_internal_has_max_bandwidth() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ServerSync::has_max_bandwidth() const {
  return _internal_has_max_bandwidth();
}
inline void ServerSync::clear_max_bandwidth() {
  max_bandwidth_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerSync::_internal_max_bandwidth() const {
  return max_bandwidth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerSync::max_bandwidth() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.max_bandwidth)
  return _internal_max_bandwidth();
}
inline void ServerSync::_internal_set_max_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  max_bandwidth_ = value;
}
inline void ServerSync::set_max_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_bandwidth(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.max_bandwidth)
}

// optional string welcome_text = 3;
inline bool ServerSync::_internal_has_welcome_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServerSync::has_welcome_text() const {
  return _internal_has_welcome_text();
}
inline void ServerSync::clear_welcome_text() {
  welcome_text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerSync::welcome_text() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.welcome_text)
  return _internal_welcome_text();
}
inline void ServerSync::set_welcome_text(const std::string& value) {
  _internal_set_welcome_text(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.welcome_text)
}
inline std::string* ServerSync::mutable_welcome_text() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ServerSync.welcome_text)
  return _internal_mutable_welcome_text();
}
inline const std::string& ServerSync::_internal_welcome_text() const {
  return welcome_text_.Get();
}
inline void ServerSync::_internal_set_welcome_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServerSync::set_welcome_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ServerSync.welcome_text)
}
inline void ServerSync::set_welcome_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ServerSync.welcome_text)
}
inline void ServerSync::set_welcome_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ServerSync.welcome_text)
}
inline std::string* ServerSync::_internal_mutable_welcome_text() {
  _has_bits_[0] |= 0x00000001u;
  return welcome_text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServerSync::release_welcome_text() {
  // @@protoc_insertion_point(field_release:MumbleProto.ServerSync.welcome_text)
  if (!_internal_has_welcome_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return welcome_text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServerSync::set_allocated_welcome_text(std::string* welcome_text) {
  if (welcome_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  welcome_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), welcome_text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ServerSync.welcome_text)
}

// optional uint64 permissions = 4;
inline bool ServerSync::_internal_has_permissions() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ServerSync::has_permissions() const {
  return _internal_has_permissions();
}
inline void ServerSync::clear_permissions() {
  permissions_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerSync::_internal_permissions() const {
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerSync::permissions() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.permissions)
  return _internal_permissions();
}
inline void ServerSync::_internal_set_permissions(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  permissions_ = value;
}
inline void ServerSync::set_permissions(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_permissions(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.permissions)
}

// -------------------------------------------------------------------

// ChannelRemove

// required uint32 channel_id = 1;
inline bool ChannelRemove::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelRemove::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void ChannelRemove::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelRemove::_internal_channel_id() const {
  return channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelRemove::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelRemove.channel_id)
  return _internal_channel_id();
}
inline void ChannelRemove::_internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_ = value;
}
inline void ChannelRemove::set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelRemove.channel_id)
}

// -------------------------------------------------------------------

// ChannelState

// optional uint32 channel_id = 1;
inline bool ChannelState::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChannelState::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void ChannelState::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::_internal_channel_id() const {
  return channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.channel_id)
  return _internal_channel_id();
}
inline void ChannelState::_internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  channel_id_ = value;
}
inline void ChannelState::set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.channel_id)
}

// optional uint32 parent = 2;
inline bool ChannelState::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChannelState::has_parent() const {
  return _internal_has_parent();
}
inline void ChannelState::clear_parent() {
  parent_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::_internal_parent() const {
  return parent_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::parent() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.parent)
  return _internal_parent();
}
inline void ChannelState::_internal_set_parent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  parent_ = value;
}
inline void ChannelState::set_parent(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_parent(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.parent)
}

// optional string name = 3;
inline bool ChannelState::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelState::has_name() const {
  return _internal_has_name();
}
inline void ChannelState::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChannelState::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.name)
  return _internal_name();
}
inline void ChannelState::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.name)
}
inline std::string* ChannelState::mutable_name() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.name)
  return _internal_mutable_name();
}
inline const std::string& ChannelState::_internal_name() const {
  return name_.Get();
}
inline void ChannelState::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChannelState::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ChannelState.name)
}
inline void ChannelState::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.name)
}
inline void ChannelState::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.name)
}
inline std::string* ChannelState::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChannelState::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.ChannelState.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.name)
}

// repeated uint32 links = 4;
inline int ChannelState::_internal_links_size() const {
  return links_.size();
}
inline int ChannelState::links_size() const {
  return _internal_links_size();
}
inline void ChannelState::clear_links() {
  links_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::_internal_links(int index) const {
  return links_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::links(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links)
  return _internal_links(index);
}
inline void ChannelState::set_links(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  links_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links)
}
inline void ChannelState::_internal_add_links(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  links_.Add(value);
}
inline void ChannelState::add_links(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_links(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ChannelState::_internal_links() const {
  return links_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ChannelState::links() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links)
  return _internal_links();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ChannelState::_internal_mutable_links() {
  return &links_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ChannelState::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links)
  return _internal_mutable_links();
}

// optional string description = 5;
inline bool ChannelState::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChannelState::has_description() const {
  return _internal_has_description();
}
inline void ChannelState::clear_description() {
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChannelState::description() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.description)
  return _internal_description();
}
inline void ChannelState::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.description)
}
inline std::string* ChannelState::mutable_description() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.description)
  return _internal_mutable_description();
}
inline const std::string& ChannelState::_internal_description() const {
  return description_.Get();
}
inline void ChannelState::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChannelState::set_description(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ChannelState.description)
}
inline void ChannelState::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.description)
}
inline void ChannelState::set_description(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.description)
}
inline std::string* ChannelState::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000002u;
  return description_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChannelState::release_description() {
  // @@protoc_insertion_point(field_release:MumbleProto.ChannelState.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelState::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.description)
}

// repeated uint32 links_add = 6;
inline int ChannelState::_internal_links_add_size() const {
  return links_add_.size();
}
inline int ChannelState::links_add_size() const {
  return _internal_links_add_size();
}
inline void ChannelState::clear_links_add() {
  links_add_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::_internal_links_add(int index) const {
  return links_add_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::links_add(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links_add)
  return _internal_links_add(index);
}
inline void ChannelState::set_links_add(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  links_add_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links_add)
}
inline void ChannelState::_internal_add_links_add(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  links_add_.Add(value);
}
inline void ChannelState::add_links_add(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_links_add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ChannelState::_internal_links_add() const {
  return links_add_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ChannelState::links_add() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links_add)
  return _internal_links_add();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ChannelState::_internal_mutable_links_add() {
  return &links_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ChannelState::mutable_links_add() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links_add)
  return _internal_mutable_links_add();
}

// repeated uint32 links_remove = 7;
inline int ChannelState::_internal_links_remove_size() const {
  return links_remove_.size();
}
inline int ChannelState::links_remove_size() const {
  return _internal_links_remove_size();
}
inline void ChannelState::clear_links_remove() {
  links_remove_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::_internal_links_remove(int index) const {
  return links_remove_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::links_remove(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links_remove)
  return _internal_links_remove(index);
}
inline void ChannelState::set_links_remove(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  links_remove_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links_remove)
}
inline void ChannelState::_internal_add_links_remove(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  links_remove_.Add(value);
}
inline void ChannelState::add_links_remove(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_links_remove(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links_remove)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ChannelState::_internal_links_remove() const {
  return links_remove_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ChannelState::links_remove() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links_remove)
  return _internal_links_remove();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ChannelState::_internal_mutable_links_remove() {
  return &links_remove_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ChannelState::mutable_links_remove() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links_remove)
  return _internal_mutable_links_remove();
}

// optional bool temporary = 8 [default = false];
inline bool ChannelState::_internal_has_temporary() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ChannelState::has_temporary() const {
  return _internal_has_temporary();
}
inline void ChannelState::clear_temporary() {
  temporary_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ChannelState::_internal_temporary() const {
  return temporary_;
}
inline bool ChannelState::temporary() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.temporary)
  return _internal_temporary();
}
inline void ChannelState::_internal_set_temporary(bool value) {
  _has_bits_[0] |= 0x00000020u;
  temporary_ = value;
}
inline void ChannelState::set_temporary(bool value) {
  _internal_set_temporary(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.temporary)
}

// optional int32 position = 9 [default = 0];
inline bool ChannelState::_internal_has_position() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ChannelState::has_position() const {
  return _internal_has_position();
}
inline void ChannelState::clear_position() {
  position_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelState::_internal_position() const {
  return position_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelState::position() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.position)
  return _internal_position();
}
inline void ChannelState::_internal_set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  position_ = value;
}
inline void ChannelState::set_position(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.position)
}

// optional bytes description_hash = 10;
inline bool ChannelState::_internal_has_description_hash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChannelState::has_description_hash() const {
  return _internal_has_description_hash();
}
inline void ChannelState::clear_description_hash() {
  description_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ChannelState::description_hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.description_hash)
  return _internal_description_hash();
}
inline void ChannelState::set_description_hash(const std::string& value) {
  _internal_set_description_hash(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.description_hash)
}
inline std::string* ChannelState::mutable_description_hash() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.description_hash)
  return _internal_mutable_description_hash();
}
inline const std::string& ChannelState::_internal_description_hash() const {
  return description_hash_.Get();
}
inline void ChannelState::_internal_set_description_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChannelState::set_description_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  description_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ChannelState.description_hash)
}
inline void ChannelState::set_description_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  description_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.description_hash)
}
inline void ChannelState::set_description_hash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  description_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.description_hash)
}
inline std::string* ChannelState::_internal_mutable_description_hash() {
  _has_bits_[0] |= 0x00000004u;
  return description_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChannelState::release_description_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.ChannelState.description_hash)
  if (!_internal_has_description_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return description_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelState::set_allocated_description_hash(std::string* description_hash) {
  if (description_hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.description_hash)
}

// optional uint32 max_users = 11;
inline bool ChannelState::_internal_has_max_users() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ChannelState::has_max_users() const {
  return _internal_has_max_users();
}
inline void ChannelState::clear_max_users() {
  max_users_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::_internal_max_users() const {
  return max_users_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelState::max_users() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.max_users)
  return _internal_max_users();
}
inline void ChannelState::_internal_set_max_users(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  max_users_ = value;
}
inline void ChannelState::set_max_users(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_users(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.max_users)
}

// -------------------------------------------------------------------

// UserRemove

// required uint32 session = 1;
inline bool UserRemove::_internal_has_session() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserRemove::has_session() const {
  return _internal_has_session();
}
inline void UserRemove::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserRemove::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserRemove::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.session)
  return _internal_session();
}
inline void UserRemove::_internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  session_ = value;
}
inline void UserRemove::set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.session)
}

// optional uint32 actor = 2;
inline bool UserRemove::_internal_has_actor() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserRemove::has_actor() const {
  return _internal_has_actor();
}
inline void UserRemove::clear_actor() {
  actor_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserRemove::_internal_actor() const {
  return actor_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserRemove::actor() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.actor)
  return _internal_actor();
}
inline void UserRemove::_internal_set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  actor_ = value;
}
inline void UserRemove::set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_actor(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.actor)
}

// optional string reason = 3;
inline bool UserRemove::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserRemove::has_reason() const {
  return _internal_has_reason();
}
inline void UserRemove::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserRemove::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.reason)
  return _internal_reason();
}
inline void UserRemove::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.reason)
}
inline std::string* UserRemove::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserRemove.reason)
  return _internal_mutable_reason();
}
inline const std::string& UserRemove::_internal_reason() const {
  return reason_.Get();
}
inline void UserRemove::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserRemove::set_reason(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserRemove.reason)
}
inline void UserRemove::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserRemove.reason)
}
inline void UserRemove::set_reason(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserRemove.reason)
}
inline std::string* UserRemove::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserRemove::release_reason() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserRemove.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserRemove::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserRemove.reason)
}

// optional bool ban = 4;
inline bool UserRemove::_internal_has_ban() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserRemove::has_ban() const {
  return _internal_has_ban();
}
inline void UserRemove::clear_ban() {
  ban_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool UserRemove::_internal_ban() const {
  return ban_;
}
inline bool UserRemove::ban() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.ban)
  return _internal_ban();
}
inline void UserRemove::_internal_set_ban(bool value) {
  _has_bits_[0] |= 0x00000008u;
  ban_ = value;
}
inline void UserRemove::set_ban(bool value) {
  _internal_set_ban(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.ban)
}

// -------------------------------------------------------------------

// UserState

// optional uint32 session = 1;
inline bool UserState::_internal_has_session() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserState::has_session() const {
  return _internal_has_session();
}
inline void UserState::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserState::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserState::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.session)
  return _internal_session();
}
inline void UserState::_internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  session_ = value;
}
inline void UserState::set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.session)
}

// optional uint32 actor = 2;
inline bool UserState::_internal_has_actor() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UserState::has_actor() const {
  return _internal_has_actor();
}
inline void UserState::clear_actor() {
  actor_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserState::_internal_actor() const {
  return actor_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserState::actor() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.actor)
  return _internal_actor();
}
inline void UserState::_internal_set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  actor_ = value;
}
inline void UserState::set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_actor(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.actor)
}

// optional string name = 3;
inline bool UserState::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserState::has_name() const {
  return _internal_has_name();
}
inline void UserState::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserState::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.name)
  return _internal_name();
}
inline void UserState::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.name)
}
inline std::string* UserState::mutable_name() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.name)
  return _internal_mutable_name();
}
inline const std::string& UserState::_internal_name() const {
  return name_.Get();
}
inline void UserState::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserState::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.name)
}
inline void UserState::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.name)
}
inline void UserState::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.name)
}
inline std::string* UserState::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserState::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.name)
}

// optional uint32 user_id = 4;
inline bool UserState::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UserState::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserState::clear_user_id() {
  user_id_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserState::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserState::user_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.user_id)
  return _internal_user_id();
}
inline void UserState::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  user_id_ = value;
}
inline void UserState::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.user_id)
}

// optional uint32 channel_id = 5;
inline bool UserState::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UserState::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void UserState::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserState::_internal_channel_id() const {
  return channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserState::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.channel_id)
  return _internal_channel_id();
}
inline void UserState::_internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  channel_id_ = value;
}
inline void UserState::set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.channel_id)
}

// optional bool mute = 6;
inline bool UserState::_internal_has_mute() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool UserState::has_mute() const {
  return _internal_has_mute();
}
inline void UserState::clear_mute() {
  mute_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool UserState::_internal_mute() const {
  return mute_;
}
inline bool UserState::mute() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.mute)
  return _internal_mute();
}
inline void UserState::_internal_set_mute(bool value) {
  _has_bits_[0] |= 0x00001000u;
  mute_ = value;
}
inline void UserState::set_mute(bool value) {
  _internal_set_mute(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.mute)
}

// optional bool deaf = 7;
inline bool UserState::_internal_has_deaf() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool UserState::has_deaf() const {
  return _internal_has_deaf();
}
inline void UserState::clear_deaf() {
  deaf_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool UserState::_internal_deaf() const {
  return deaf_;
}
inline bool UserState::deaf() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.deaf)
  return _internal_deaf();
}
inline void UserState::_internal_set_deaf(bool value) {
  _has_bits_[0] |= 0x00002000u;
  deaf_ = value;
}
inline void UserState::set_deaf(bool value) {
  _internal_set_deaf(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.deaf)
}

// optional bool suppress = 8;
inline bool UserState::_internal_has_suppress() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool UserState::has_suppress() const {
  return _internal_has_suppress();
}
inline void UserState::clear_suppress() {
  suppress_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool UserState::_internal_suppress() const {
  return suppress_;
}
inline bool UserState::suppress() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.suppress)
  return _internal_suppress();
}
inline void UserState::_internal_set_suppress(bool value) {
  _has_bits_[0] |= 0x00004000u;
  suppress_ = value;
}
inline void UserState::set_suppress(bool value) {
  _internal_set_suppress(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.suppress)
}

// optional bool self_mute = 9;
inline bool UserState::_internal_has_self_mute() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool UserState::has_self_mute() const {
  return _internal_has_self_mute();
}
inline void UserState::clear_self_mute() {
  self_mute_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool UserState::_internal_self_mute() const {
  return self_mute_;
}
inline bool UserState::self_mute() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.self_mute)
  return _internal_self_mute();
}
inline void UserState::_internal_set_self_mute(bool value) {
  _has_bits_[0] |= 0x00008000u;
  self_mute_ = value;
}
inline void UserState::set_self_mute(bool value) {
  _internal_set_self_mute(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.self_mute)
}

// optional bool self_deaf = 10;
inline bool UserState::_internal_has_self_deaf() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool UserState::has_self_deaf() const {
  return _internal_has_self_deaf();
}
inline void UserState::clear_self_deaf() {
  self_deaf_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool UserState::_internal_self_deaf() const {
  return self_deaf_;
}
inline bool UserState::self_deaf() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.self_deaf)
  return _internal_self_deaf();
}
inline void UserState::_internal_set_self_deaf(bool value) {
  _has_bits_[0] |= 0x00010000u;
  self_deaf_ = value;
}
inline void UserState::set_self_deaf(bool value) {
  _internal_set_self_deaf(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.self_deaf)
}

// optional bytes texture = 11;
inline bool UserState::_internal_has_texture() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserState::has_texture() const {
  return _internal_has_texture();
}
inline void UserState::clear_texture() {
  texture_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserState::texture() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.texture)
  return _internal_texture();
}
inline void UserState::set_texture(const std::string& value) {
  _internal_set_texture(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.texture)
}
inline std::string* UserState::mutable_texture() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.texture)
  return _internal_mutable_texture();
}
inline const std::string& UserState::_internal_texture() const {
  return texture_.Get();
}
inline void UserState::_internal_set_texture(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  texture_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserState::set_texture(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  texture_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.texture)
}
inline void UserState::set_texture(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  texture_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.texture)
}
inline void UserState::set_texture(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  texture_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.texture)
}
inline std::string* UserState::_internal_mutable_texture() {
  _has_bits_[0] |= 0x00000002u;
  return texture_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserState::release_texture() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.texture)
  if (!_internal_has_texture()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return texture_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserState::set_allocated_texture(std::string* texture) {
  if (texture != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  texture_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), texture,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.texture)
}

// optional bytes plugin_context = 12;
inline bool UserState::_internal_has_plugin_context() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserState::has_plugin_context() const {
  return _internal_has_plugin_context();
}
inline void UserState::clear_plugin_context() {
  plugin_context_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserState::plugin_context() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.plugin_context)
  return _internal_plugin_context();
}
inline void UserState::set_plugin_context(const std::string& value) {
  _internal_set_plugin_context(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.plugin_context)
}
inline std::string* UserState::mutable_plugin_context() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.plugin_context)
  return _internal_mutable_plugin_context();
}
inline const std::string& UserState::_internal_plugin_context() const {
  return plugin_context_.Get();
}
inline void UserState::_internal_set_plugin_context(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  plugin_context_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserState::set_plugin_context(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  plugin_context_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.plugin_context)
}
inline void UserState::set_plugin_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  plugin_context_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.plugin_context)
}
inline void UserState::set_plugin_context(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  plugin_context_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.plugin_context)
}
inline std::string* UserState::_internal_mutable_plugin_context() {
  _has_bits_[0] |= 0x00000004u;
  return plugin_context_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserState::release_plugin_context() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.plugin_context)
  if (!_internal_has_plugin_context()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return plugin_context_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserState::set_allocated_plugin_context(std::string* plugin_context) {
  if (plugin_context != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  plugin_context_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_context,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.plugin_context)
}

// optional string plugin_identity = 13;
inline bool UserState::_internal_has_plugin_identity() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserState::has_plugin_identity() const {
  return _internal_has_plugin_identity();
}
inline void UserState::clear_plugin_identity() {
  plugin_identity_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserState::plugin_identity() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.plugin_identity)
  return _internal_plugin_identity();
}
inline void UserState::set_plugin_identity(const std::string& value) {
  _internal_set_plugin_identity(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.plugin_identity)
}
inline std::string* UserState::mutable_plugin_identity() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.plugin_identity)
  return _internal_mutable_plugin_identity();
}
inline const std::string& UserState::_internal_plugin_identity() const {
  return plugin_identity_.Get();
}
inline void UserState::_internal_set_plugin_identity(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  plugin_identity_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserState::set_plugin_identity(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  plugin_identity_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.plugin_identity)
}
inline void UserState::set_plugin_identity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  plugin_identity_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.plugin_identity)
}
inline void UserState::set_plugin_identity(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  plugin_identity_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.plugin_identity)
}
inline std::string* UserState::_internal_mutable_plugin_identity() {
  _has_bits_[0] |= 0x00000008u;
  return plugin_identity_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserState::release_plugin_identity() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.plugin_identity)
  if (!_internal_has_plugin_identity()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return plugin_identity_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserState::set_allocated_plugin_identity(std::string* plugin_identity) {
  if (plugin_identity != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  plugin_identity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), plugin_identity,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.plugin_identity)
}

// optional string comment = 14;
inline bool UserState::_internal_has_comment() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserState::has_comment() const {
  return _internal_has_comment();
}
inline void UserState::clear_comment() {
  comment_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserState::comment() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.comment)
  return _internal_comment();
}
inline void UserState::set_comment(const std::string& value) {
  _internal_set_comment(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.comment)
}
inline std::string* UserState::mutable_comment() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.comment)
  return _internal_mutable_comment();
}
inline const std::string& UserState::_internal_comment() const {
  return comment_.Get();
}
inline void UserState::_internal_set_comment(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  comment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserState::set_comment(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  comment_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.comment)
}
inline void UserState::set_comment(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  comment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.comment)
}
inline void UserState::set_comment(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  comment_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.comment)
}
inline std::string* UserState::_internal_mutable_comment() {
  _has_bits_[0] |= 0x00000010u;
  return comment_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserState::release_comment() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return comment_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserState::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  comment_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.comment)
}

// optional string hash = 15;
inline bool UserState::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserState::has_hash() const {
  return _internal_has_hash();
}
inline void UserState::clear_hash() {
  hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserState::hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.hash)
  return _internal_hash();
}
inline void UserState::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.hash)
}
inline std::string* UserState::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.hash)
  return _internal_mutable_hash();
}
inline const std::string& UserState::_internal_hash() const {
  return hash_.Get();
}
inline void UserState::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserState::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.hash)
}
inline void UserState::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.hash)
}
inline void UserState::set_hash(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.hash)
}
inline std::string* UserState::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000020u;
  return hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserState::release_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserState::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.hash)
}

// optional bytes comment_hash = 16;
inline bool UserState::_internal_has_comment_hash() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserState::has_comment_hash() const {
  return _internal_has_comment_hash();
}
inline void UserState::clear_comment_hash() {
  comment_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& UserState::comment_hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.comment_hash)
  return _internal_comment_hash();
}
inline void UserState::set_comment_hash(const std::string& value) {
  _internal_set_comment_hash(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.comment_hash)
}
inline std::string* UserState::mutable_comment_hash() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.comment_hash)
  return _internal_mutable_comment_hash();
}
inline const std::string& UserState::_internal_comment_hash() const {
  return comment_hash_.Get();
}
inline void UserState::_internal_set_comment_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  comment_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserState::set_comment_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  comment_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.comment_hash)
}
inline void UserState::set_comment_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  comment_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.comment_hash)
}
inline void UserState::set_comment_hash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  comment_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.comment_hash)
}
inline std::string* UserState::_internal_mutable_comment_hash() {
  _has_bits_[0] |= 0x00000040u;
  return comment_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserState::release_comment_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.comment_hash)
  if (!_internal_has_comment_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return comment_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserState::set_allocated_comment_hash(std::string* comment_hash) {
  if (comment_hash != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  comment_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.comment_hash)
}

// optional bytes texture_hash = 17;
inline bool UserState::_internal_has_texture_hash() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserState::has_texture_hash() const {
  return _internal_has_texture_hash();
}
inline void UserState::clear_texture_hash() {
  texture_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& UserState::texture_hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.texture_hash)
  return _internal_texture_hash();
}
inline void UserState::set_texture_hash(const std::string& value) {
  _internal_set_texture_hash(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.texture_hash)
}
inline std::string* UserState::mutable_texture_hash() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.texture_hash)
  return _internal_mutable_texture_hash();
}
inline const std::string& UserState::_internal_texture_hash() const {
  return texture_hash_.Get();
}
inline void UserState::_internal_set_texture_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  texture_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserState::set_texture_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  texture_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.texture_hash)
}
inline void UserState::set_texture_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  texture_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.texture_hash)
}
inline void UserState::set_texture_hash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000080u;
  texture_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.texture_hash)
}
inline std::string* UserState::_internal_mutable_texture_hash() {
  _has_bits_[0] |= 0x00000080u;
  return texture_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserState::release_texture_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.texture_hash)
  if (!_internal_has_texture_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return texture_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserState::set_allocated_texture_hash(std::string* texture_hash) {
  if (texture_hash != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  texture_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), texture_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.texture_hash)
}

// optional bool priority_speaker = 18;
inline bool UserState::_internal_has_priority_speaker() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool UserState::has_priority_speaker() const {
  return _internal_has_priority_speaker();
}
inline void UserState::clear_priority_speaker() {
  priority_speaker_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool UserState::_internal_priority_speaker() const {
  return priority_speaker_;
}
inline bool UserState::priority_speaker() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.priority_speaker)
  return _internal_priority_speaker();
}
inline void UserState::_internal_set_priority_speaker(bool value) {
  _has_bits_[0] |= 0x00020000u;
  priority_speaker_ = value;
}
inline void UserState::set_priority_speaker(bool value) {
  _internal_set_priority_speaker(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.priority_speaker)
}

// optional bool recording = 19;
inline bool UserState::_internal_has_recording() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool UserState::has_recording() const {
  return _internal_has_recording();
}
inline void UserState::clear_recording() {
  recording_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool UserState::_internal_recording() const {
  return recording_;
}
inline bool UserState::recording() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.recording)
  return _internal_recording();
}
inline void UserState::_internal_set_recording(bool value) {
  _has_bits_[0] |= 0x00040000u;
  recording_ = value;
}
inline void UserState::set_recording(bool value) {
  _internal_set_recording(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.recording)
}

// -------------------------------------------------------------------

// BanList_BanEntry

// required bytes address = 1;
inline bool BanList_BanEntry::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BanList_BanEntry::has_address() const {
  return _internal_has_address();
}
inline void BanList_BanEntry::clear_address() {
  address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BanList_BanEntry::address() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.address)
  return _internal_address();
}
inline void BanList_BanEntry::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.address)
}
inline std::string* BanList_BanEntry::mutable_address() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.address)
  return _internal_mutable_address();
}
inline const std::string& BanList_BanEntry::_internal_address() const {
  return address_.Get();
}
inline void BanList_BanEntry::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BanList_BanEntry::set_address(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.address)
}
inline void BanList_BanEntry::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.address)
}
inline void BanList_BanEntry::set_address(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.address)
}
inline std::string* BanList_BanEntry::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BanList_BanEntry::release_address() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BanList_BanEntry::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.address)
}

// required uint32 mask = 2;
inline bool BanList_BanEntry::_internal_has_mask() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BanList_BanEntry::has_mask() const {
  return _internal_has_mask();
}
inline void BanList_BanEntry::clear_mask() {
  mask_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BanList_BanEntry::_internal_mask() const {
  return mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BanList_BanEntry::mask() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.mask)
  return _internal_mask();
}
inline void BanList_BanEntry::_internal_set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  mask_ = value;
}
inline void BanList_BanEntry::set_mask(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.mask)
}

// optional string name = 3;
inline bool BanList_BanEntry::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BanList_BanEntry::has_name() const {
  return _internal_has_name();
}
inline void BanList_BanEntry::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BanList_BanEntry::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.name)
  return _internal_name();
}
inline void BanList_BanEntry::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.name)
}
inline std::string* BanList_BanEntry::mutable_name() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.name)
  return _internal_mutable_name();
}
inline const std::string& BanList_BanEntry::_internal_name() const {
  return name_.Get();
}
inline void BanList_BanEntry::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BanList_BanEntry::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.name)
}
inline void BanList_BanEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.name)
}
inline void BanList_BanEntry::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.name)
}
inline std::string* BanList_BanEntry::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BanList_BanEntry::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BanList_BanEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.name)
}

// optional string hash = 4;
inline bool BanList_BanEntry::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BanList_BanEntry::has_hash() const {
  return _internal_has_hash();
}
inline void BanList_BanEntry::clear_hash() {
  hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BanList_BanEntry::hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.hash)
  return _internal_hash();
}
inline void BanList_BanEntry::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.hash)
}
inline std::string* BanList_BanEntry::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.hash)
  return _internal_mutable_hash();
}
inline const std::string& BanList_BanEntry::_internal_hash() const {
  return hash_.Get();
}
inline void BanList_BanEntry::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BanList_BanEntry::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.hash)
}
inline void BanList_BanEntry::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.hash)
}
inline void BanList_BanEntry::set_hash(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.hash)
}
inline std::string* BanList_BanEntry::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000004u;
  return hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BanList_BanEntry::release_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BanList_BanEntry::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.hash)
}

// optional string reason = 5;
inline bool BanList_BanEntry::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BanList_BanEntry::has_reason() const {
  return _internal_has_reason();
}
inline void BanList_BanEntry::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BanList_BanEntry::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.reason)
  return _internal_reason();
}
inline void BanList_BanEntry::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.reason)
}
inline std::string* BanList_BanEntry::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.reason)
  return _internal_mutable_reason();
}
inline const std::string& BanList_BanEntry::_internal_reason() const {
  return reason_.Get();
}
inline void BanList_BanEntry::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BanList_BanEntry::set_reason(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.reason)
}
inline void BanList_BanEntry::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.reason)
}
inline void BanList_BanEntry::set_reason(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.reason)
}
inline std::string* BanList_BanEntry::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000008u;
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BanList_BanEntry::release_reason() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return reason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BanList_BanEntry::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.reason)
}

// optional string start = 6;
inline bool BanList_BanEntry::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BanList_BanEntry::has_start() const {
  return _internal_has_start();
}
inline void BanList_BanEntry::clear_start() {
  start_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BanList_BanEntry::start() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.start)
  return _internal_start();
}
inline void BanList_BanEntry::set_start(const std::string& value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.start)
}
inline std::string* BanList_BanEntry::mutable_start() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.start)
  return _internal_mutable_start();
}
inline const std::string& BanList_BanEntry::_internal_start() const {
  return start_.Get();
}
inline void BanList_BanEntry::_internal_set_start(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  start_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BanList_BanEntry::set_start(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  start_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.start)
}
inline void BanList_BanEntry::set_start(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  start_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.start)
}
inline void BanList_BanEntry::set_start(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  start_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.start)
}
inline std::string* BanList_BanEntry::_internal_mutable_start() {
  _has_bits_[0] |= 0x00000010u;
  return start_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BanList_BanEntry::release_start() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.start)
  if (!_internal_has_start()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return start_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BanList_BanEntry::set_allocated_start(std::string* start) {
  if (start != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  start_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.start)
}

// optional uint32 duration = 7;
inline bool BanList_BanEntry::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BanList_BanEntry::has_duration() const {
  return _internal_has_duration();
}
inline void BanList_BanEntry::clear_duration() {
  duration_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BanList_BanEntry::_internal_duration() const {
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BanList_BanEntry::duration() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.duration)
  return _internal_duration();
}
inline void BanList_BanEntry::_internal_set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  duration_ = value;
}
inline void BanList_BanEntry::set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.duration)
}

// -------------------------------------------------------------------

// BanList

// repeated .MumbleProto.BanList.BanEntry bans = 1;
inline int BanList::_internal_bans_size() const {
  return bans_.size();
}
inline int BanList::bans_size() const {
  return _internal_bans_size();
}
inline void BanList::clear_bans() {
  bans_.Clear();
}
inline ::MumbleProto::BanList_BanEntry* BanList::mutable_bans(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.bans)
  return bans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
BanList::mutable_bans() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.BanList.bans)
  return &bans_;
}
inline const ::MumbleProto::BanList_BanEntry& BanList::_internal_bans(int index) const {
  return bans_.Get(index);
}
inline const ::MumbleProto::BanList_BanEntry& BanList::bans(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.bans)
  return _internal_bans(index);
}
inline ::MumbleProto::BanList_BanEntry* BanList::_internal_add_bans() {
  return bans_.Add();
}
inline ::MumbleProto::BanList_BanEntry* BanList::add_bans() {
  // @@protoc_insertion_point(field_add:MumbleProto.BanList.bans)
  return _internal_add_bans();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
BanList::bans() const {
  // @@protoc_insertion_point(field_list:MumbleProto.BanList.bans)
  return bans_;
}

// optional bool query = 2 [default = false];
inline bool BanList::_internal_has_query() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BanList::has_query() const {
  return _internal_has_query();
}
inline void BanList::clear_query() {
  query_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool BanList::_internal_query() const {
  return query_;
}
inline bool BanList::query() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.query)
  return _internal_query();
}
inline void BanList::_internal_set_query(bool value) {
  _has_bits_[0] |= 0x00000001u;
  query_ = value;
}
inline void BanList::set_query(bool value) {
  _internal_set_query(value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.query)
}

// -------------------------------------------------------------------

// TextMessage

// optional uint32 actor = 1;
inline bool TextMessage::_internal_has_actor() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TextMessage::has_actor() const {
  return _internal_has_actor();
}
inline void TextMessage::clear_actor() {
  actor_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TextMessage::_internal_actor() const {
  return actor_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TextMessage::actor() const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.actor)
  return _internal_actor();
}
inline void TextMessage::_internal_set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  actor_ = value;
}
inline void TextMessage::set_actor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_actor(value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.actor)
}

// repeated uint32 session = 2;
inline int TextMessage::_internal_session_size() const {
  return session_.size();
}
inline int TextMessage::session_size() const {
  return _internal_session_size();
}
inline void TextMessage::clear_session() {
  session_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TextMessage::_internal_session(int index) const {
  return session_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TextMessage::session(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.session)
  return _internal_session(index);
}
inline void TextMessage::set_session(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  session_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.session)
}
inline void TextMessage::_internal_add_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  session_.Add(value);
}
inline void TextMessage::add_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_session(value);
  // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.session)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
TextMessage::_internal_session() const {
  return session_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
TextMessage::session() const {
  // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.session)
  return _internal_session();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
TextMessage::_internal_mutable_session() {
  return &session_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
TextMessage::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.session)
  return _internal_mutable_session();
}

// repeated uint32 channel_id = 3;
inline int TextMessage::_internal_channel_id_size() const {
  return channel_id_.size();
}
inline int TextMessage::channel_id_size() const {
  return _internal_channel_id_size();
}
inline void TextMessage::clear_channel_id() {
  channel_id_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TextMessage::_internal_channel_id(int index) const {
  return channel_id_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TextMessage::channel_id(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.channel_id)
  return _internal_channel_id(index);
}
inline void TextMessage::set_channel_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  channel_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.channel_id)
}
inline void TextMessage::_internal_add_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  channel_id_.Add(value);
}
inline void TextMessage::add_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_channel_id(value);
  // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.channel_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
TextMessage::_internal_channel_id() const {
  return channel_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
TextMessage::channel_id() const {
  // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.channel_id)
  return _internal_channel_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
TextMessage::_internal_mutable_channel_id() {
  return &channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
TextMessage::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.channel_id)
  return _internal_mutable_channel_id();
}

// repeated uint32 tree_id = 4;
inline int TextMessage::_internal_tree_id_size() const {
  return tree_id_.size();
}
inline int TextMessage::tree_id_size() const {
  return _internal_tree_id_size();
}
inline void TextMessage::clear_tree_id() {
  tree_id_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TextMessage::_internal_tree_id(int index) const {
  return tree_id_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TextMessage::tree_id(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.tree_id)
  return _internal_tree_id(index);
}
inline void TextMessage::set_tree_id(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  tree_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.tree_id)
}
inline void TextMessage::_internal_add_tree_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  tree_id_.Add(value);
}
inline void TextMessage::add_tree_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_tree_id(value);
  // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.tree_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
TextMessage::_internal_tree_id() const {
  return tree_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
TextMessage::tree_id() const {
  // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.tree_id)
  return _internal_tree_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
TextMessage::_internal_mutable_tree_id() {
  return &tree_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
TextMessage::mutable_tree_id() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.tree_id)
  return _internal_mutable_tree_id();
}

// required string message = 5;
inline bool TextMessage::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TextMessage::has_message() const {
  return _internal_has_message();
}
inline void TextMessage::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextMessage::message() const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.message)
  return _internal_message();
}
inline void TextMessage::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.message)
}
inline std::string* TextMessage::mutable_message() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.TextMessage.message)
  return _internal_mutable_message();
}
inline const std::string& TextMessage::_internal_message() const {
  return message_.Get();
}
inline void TextMessage::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TextMessage::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.TextMessage.message)
}
inline void TextMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.TextMessage.message)
}
inline void TextMessage::set_message(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.TextMessage.message)
}
inline std::string* TextMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TextMessage::release_message() {
  // @@protoc_insertion_point(field_release:MumbleProto.TextMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TextMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.TextMessage.message)
}

// -------------------------------------------------------------------

// PermissionDenied

// optional uint32 permission = 1;
inline bool PermissionDenied::_internal_has_permission() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PermissionDenied::has_permission() const {
  return _internal_has_permission();
}
inline void PermissionDenied::clear_permission() {
  permission_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionDenied::_internal_permission() const {
  return permission_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionDenied::permission() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.permission)
  return _internal_permission();
}
inline void PermissionDenied::_internal_set_permission(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  permission_ = value;
}
inline void PermissionDenied::set_permission(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_permission(value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.permission)
}

// optional uint32 channel_id = 2;
inline bool PermissionDenied::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PermissionDenied::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void PermissionDenied::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionDenied::_internal_channel_id() const {
  return channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionDenied::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.channel_id)
  return _internal_channel_id();
}
inline void PermissionDenied::_internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  channel_id_ = value;
}
inline void PermissionDenied::set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.channel_id)
}

// optional uint32 session = 3;
inline bool PermissionDenied::_internal_has_session() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PermissionDenied::has_session() const {
  return _internal_has_session();
}
inline void PermissionDenied::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionDenied::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionDenied::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.session)
  return _internal_session();
}
inline void PermissionDenied::_internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  session_ = value;
}
inline void PermissionDenied::set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.session)
}

// optional string reason = 4;
inline bool PermissionDenied::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PermissionDenied::has_reason() const {
  return _internal_has_reason();
}
inline void PermissionDenied::clear_reason() {
  reason_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PermissionDenied::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.reason)
  return _internal_reason();
}
inline void PermissionDenied::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.reason)
}
inline std::string* PermissionDenied::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.PermissionDenied.reason)
  return _internal_mutable_reason();
}
inline const std::string& PermissionDenied::_internal_reason() const {
  return reason_.Get();
}
inline void PermissionDenied::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PermissionDenied::set_reason(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.PermissionDenied.reason)
}
inline void PermissionDenied::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.PermissionDenied.reason)
}
inline void PermissionDenied::set_reason(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.PermissionDenied.reason)
}
inline std::string* PermissionDenied::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  return reason_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PermissionDenied::release_reason() {
  // @@protoc_insertion_point(field_release:MumbleProto.PermissionDenied.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PermissionDenied::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.PermissionDenied.reason)
}

// optional .MumbleProto.PermissionDenied.DenyType type = 5;
inline bool PermissionDenied::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PermissionDenied::has_type() const {
  return _internal_has_type();
}
inline void PermissionDenied::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::MumbleProto::PermissionDenied_DenyType PermissionDenied::_internal_type() const {
  return static_cast< ::MumbleProto::PermissionDenied_DenyType >(type_);
}
inline ::MumbleProto::PermissionDenied_DenyType PermissionDenied::type() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.type)
  return _internal_type();
}
inline void PermissionDenied::_internal_set_type(::MumbleProto::PermissionDenied_DenyType value) {
  assert(::MumbleProto::PermissionDenied_DenyType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
}
inline void PermissionDenied::set_type(::MumbleProto::PermissionDenied_DenyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.type)
}

// optional string name = 6;
inline bool PermissionDenied::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PermissionDenied::has_name() const {
  return _internal_has_name();
}
inline void PermissionDenied::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PermissionDenied::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.name)
  return _internal_name();
}
inline void PermissionDenied::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.name)
}
inline std::string* PermissionDenied::mutable_name() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.PermissionDenied.name)
  return _internal_mutable_name();
}
inline const std::string& PermissionDenied::_internal_name() const {
  return name_.Get();
}
inline void PermissionDenied::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PermissionDenied::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.PermissionDenied.name)
}
inline void PermissionDenied::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.PermissionDenied.name)
}
inline void PermissionDenied::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.PermissionDenied.name)
}
inline std::string* PermissionDenied::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PermissionDenied::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.PermissionDenied.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PermissionDenied::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.PermissionDenied.name)
}

// -------------------------------------------------------------------

// ACL_ChanGroup

// required string name = 1;
inline bool ACL_ChanGroup::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ACL_ChanGroup::has_name() const {
  return _internal_has_name();
}
inline void ACL_ChanGroup::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ACL_ChanGroup::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.name)
  return _internal_name();
}
inline void ACL_ChanGroup::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.name)
}
inline std::string* ACL_ChanGroup::mutable_name() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.ChanGroup.name)
  return _internal_mutable_name();
}
inline const std::string& ACL_ChanGroup::_internal_name() const {
  return name_.Get();
}
inline void ACL_ChanGroup::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ACL_ChanGroup::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ACL.ChanGroup.name)
}
inline void ACL_ChanGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ACL.ChanGroup.name)
}
inline void ACL_ChanGroup::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ACL.ChanGroup.name)
}
inline std::string* ACL_ChanGroup::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ACL_ChanGroup::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.ACL.ChanGroup.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ACL_ChanGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ACL.ChanGroup.name)
}

// optional bool inherited = 2 [default = true];
inline bool ACL_ChanGroup::_internal_has_inherited() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ACL_ChanGroup::has_inherited() const {
  return _internal_has_inherited();
}
inline void ACL_ChanGroup::clear_inherited() {
  inherited_ = true;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ACL_ChanGroup::_internal_inherited() const {
  return inherited_;
}
inline bool ACL_ChanGroup::inherited() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherited)
  return _internal_inherited();
}
inline void ACL_ChanGroup::_internal_set_inherited(bool value) {
  _has_bits_[0] |= 0x00000002u;
  inherited_ = value;
}
inline void ACL_ChanGroup::set_inherited(bool value) {
  _internal_set_inherited(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherited)
}

// optional bool inherit = 3 [default = true];
inline bool ACL_ChanGroup::_internal_has_inherit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ACL_ChanGroup::has_inherit() const {
  return _internal_has_inherit();
}
inline void ACL_ChanGroup::clear_inherit() {
  inherit_ = true;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ACL_ChanGroup::_internal_inherit() const {
  return inherit_;
}
inline bool ACL_ChanGroup::inherit() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherit)
  return _internal_inherit();
}
inline void ACL_ChanGroup::_internal_set_inherit(bool value) {
  _has_bits_[0] |= 0x00000004u;
  inherit_ = value;
}
inline void ACL_ChanGroup::set_inherit(bool value) {
  _internal_set_inherit(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherit)
}

// optional bool inheritable = 4 [default = true];
inline bool ACL_ChanGroup::_internal_has_inheritable() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ACL_ChanGroup::has_inheritable() const {
  return _internal_has_inheritable();
}
inline void ACL_ChanGroup::clear_inheritable() {
  inheritable_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ACL_ChanGroup::_internal_inheritable() const {
  return inheritable_;
}
inline bool ACL_ChanGroup::inheritable() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inheritable)
  return _internal_inheritable();
}
inline void ACL_ChanGroup::_internal_set_inheritable(bool value) {
  _has_bits_[0] |= 0x00000008u;
  inheritable_ = value;
}
inline void ACL_ChanGroup::set_inheritable(bool value) {
  _internal_set_inheritable(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inheritable)
}

// repeated uint32 add = 5;
inline int ACL_ChanGroup::_internal_add_size() const {
  return add_.size();
}
inline int ACL_ChanGroup::add_size() const {
  return _internal_add_size();
}
inline void ACL_ChanGroup::clear_add() {
  add_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanGroup::_internal_add(int index) const {
  return add_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanGroup::add(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.add)
  return _internal_add(index);
}
inline void ACL_ChanGroup::set_add(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  add_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.add)
}
inline void ACL_ChanGroup::_internal_add_add(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  add_.Add(value);
}
inline void ACL_ChanGroup::add_add(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ACL_ChanGroup::_internal_add() const {
  return add_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ACL_ChanGroup::add() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.add)
  return _internal_add();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ACL_ChanGroup::_internal_mutable_add() {
  return &add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ACL_ChanGroup::mutable_add() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.add)
  return _internal_mutable_add();
}

// repeated uint32 remove = 6;
inline int ACL_ChanGroup::_internal_remove_size() const {
  return remove_.size();
}
inline int ACL_ChanGroup::remove_size() const {
  return _internal_remove_size();
}
inline void ACL_ChanGroup::clear_remove() {
  remove_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanGroup::_internal_remove(int index) const {
  return remove_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanGroup::remove(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.remove)
  return _internal_remove(index);
}
inline void ACL_ChanGroup::set_remove(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  remove_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.remove)
}
inline void ACL_ChanGroup::_internal_add_remove(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  remove_.Add(value);
}
inline void ACL_ChanGroup::add_remove(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_remove(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.remove)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ACL_ChanGroup::_internal_remove() const {
  return remove_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ACL_ChanGroup::remove() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.remove)
  return _internal_remove();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ACL_ChanGroup::_internal_mutable_remove() {
  return &remove_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ACL_ChanGroup::mutable_remove() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.remove)
  return _internal_mutable_remove();
}

// repeated uint32 inherited_members = 7;
inline int ACL_ChanGroup::_internal_inherited_members_size() const {
  return inherited_members_.size();
}
inline int ACL_ChanGroup::inherited_members_size() const {
  return _internal_inherited_members_size();
}
inline void ACL_ChanGroup::clear_inherited_members() {
  inherited_members_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanGroup::_internal_inherited_members(int index) const {
  return inherited_members_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanGroup::inherited_members(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherited_members)
  return _internal_inherited_members(index);
}
inline void ACL_ChanGroup::set_inherited_members(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  inherited_members_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherited_members)
}
inline void ACL_ChanGroup::_internal_add_inherited_members(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  inherited_members_.Add(value);
}
inline void ACL_ChanGroup::add_inherited_members(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_inherited_members(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.inherited_members)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ACL_ChanGroup::_internal_inherited_members() const {
  return inherited_members_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ACL_ChanGroup::inherited_members() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.inherited_members)
  return _internal_inherited_members();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ACL_ChanGroup::_internal_mutable_inherited_members() {
  return &inherited_members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ACL_ChanGroup::mutable_inherited_members() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.inherited_members)
  return _internal_mutable_inherited_members();
}

// -------------------------------------------------------------------

// ACL_ChanACL

// optional bool apply_here = 1 [default = true];
inline bool ACL_ChanACL::_internal_has_apply_here() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ACL_ChanACL::has_apply_here() const {
  return _internal_has_apply_here();
}
inline void ACL_ChanACL::clear_apply_here() {
  apply_here_ = true;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ACL_ChanACL::_internal_apply_here() const {
  return apply_here_;
}
inline bool ACL_ChanACL::apply_here() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.apply_here)
  return _internal_apply_here();
}
inline void ACL_ChanACL::_internal_set_apply_here(bool value) {
  _has_bits_[0] |= 0x00000010u;
  apply_here_ = value;
}
inline void ACL_ChanACL::set_apply_here(bool value) {
  _internal_set_apply_here(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.apply_here)
}

// optional bool apply_subs = 2 [default = true];
inline bool ACL_ChanACL::_internal_has_apply_subs() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ACL_ChanACL::has_apply_subs() const {
  return _internal_has_apply_subs();
}
inline void ACL_ChanACL::clear_apply_subs() {
  apply_subs_ = true;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ACL_ChanACL::_internal_apply_subs() const {
  return apply_subs_;
}
inline bool ACL_ChanACL::apply_subs() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.apply_subs)
  return _internal_apply_subs();
}
inline void ACL_ChanACL::_internal_set_apply_subs(bool value) {
  _has_bits_[0] |= 0x00000020u;
  apply_subs_ = value;
}
inline void ACL_ChanACL::set_apply_subs(bool value) {
  _internal_set_apply_subs(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.apply_subs)
}

// optional bool inherited = 3 [default = true];
inline bool ACL_ChanACL::_internal_has_inherited() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ACL_ChanACL::has_inherited() const {
  return _internal_has_inherited();
}
inline void ACL_ChanACL::clear_inherited() {
  inherited_ = true;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ACL_ChanACL::_internal_inherited() const {
  return inherited_;
}
inline bool ACL_ChanACL::inherited() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.inherited)
  return _internal_inherited();
}
inline void ACL_ChanACL::_internal_set_inherited(bool value) {
  _has_bits_[0] |= 0x00000040u;
  inherited_ = value;
}
inline void ACL_ChanACL::set_inherited(bool value) {
  _internal_set_inherited(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.inherited)
}

// optional uint32 user_id = 4;
inline bool ACL_ChanACL::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ACL_ChanACL::has_user_id() const {
  return _internal_has_user_id();
}
inline void ACL_ChanACL::clear_user_id() {
  user_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanACL::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanACL::user_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.user_id)
  return _internal_user_id();
}
inline void ACL_ChanACL::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  user_id_ = value;
}
inline void ACL_ChanACL::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.user_id)
}

// optional string group = 5;
inline bool ACL_ChanACL::_internal_has_group() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ACL_ChanACL::has_group() const {
  return _internal_has_group();
}
inline void ACL_ChanACL::clear_group() {
  group_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ACL_ChanACL::group() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.group)
  return _internal_group();
}
inline void ACL_ChanACL::set_group(const std::string& value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.group)
}
inline std::string* ACL_ChanACL::mutable_group() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.ChanACL.group)
  return _internal_mutable_group();
}
inline const std::string& ACL_ChanACL::_internal_group() const {
  return group_.Get();
}
inline void ACL_ChanACL::_internal_set_group(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ACL_ChanACL::set_group(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ACL.ChanACL.group)
}
inline void ACL_ChanACL::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ACL.ChanACL.group)
}
inline void ACL_ChanACL::set_group(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ACL.ChanACL.group)
}
inline std::string* ACL_ChanACL::_internal_mutable_group() {
  _has_bits_[0] |= 0x00000001u;
  return group_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ACL_ChanACL::release_group() {
  // @@protoc_insertion_point(field_release:MumbleProto.ACL.ChanACL.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return group_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ACL_ChanACL::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ACL.ChanACL.group)
}

// optional uint32 grant = 6;
inline bool ACL_ChanACL::_internal_has_grant() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ACL_ChanACL::has_grant() const {
  return _internal_has_grant();
}
inline void ACL_ChanACL::clear_grant() {
  grant_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanACL::_internal_grant() const {
  return grant_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanACL::grant() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.grant)
  return _internal_grant();
}
inline void ACL_ChanACL::_internal_set_grant(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  grant_ = value;
}
inline void ACL_ChanACL::set_grant(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_grant(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.grant)
}

// optional uint32 deny = 7;
inline bool ACL_ChanACL::_internal_has_deny() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ACL_ChanACL::has_deny() const {
  return _internal_has_deny();
}
inline void ACL_ChanACL::clear_deny() {
  deny_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanACL::_internal_deny() const {
  return deny_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL_ChanACL::deny() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.deny)
  return _internal_deny();
}
inline void ACL_ChanACL::_internal_set_deny(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  deny_ = value;
}
inline void ACL_ChanACL::set_deny(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_deny(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.deny)
}

// -------------------------------------------------------------------

// ACL

// required uint32 channel_id = 1;
inline bool ACL::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ACL::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void ACL::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL::_internal_channel_id() const {
  return channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ACL::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.channel_id)
  return _internal_channel_id();
}
inline void ACL::_internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_ = value;
}
inline void ACL::set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.channel_id)
}

// optional bool inherit_acls = 2 [default = true];
inline bool ACL::_internal_has_inherit_acls() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ACL::has_inherit_acls() const {
  return _internal_has_inherit_acls();
}
inline void ACL::clear_inherit_acls() {
  inherit_acls_ = true;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ACL::_internal_inherit_acls() const {
  return inherit_acls_;
}
inline bool ACL::inherit_acls() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.inherit_acls)
  return _internal_inherit_acls();
}
inline void ACL::_internal_set_inherit_acls(bool value) {
  _has_bits_[0] |= 0x00000004u;
  inherit_acls_ = value;
}
inline void ACL::set_inherit_acls(bool value) {
  _internal_set_inherit_acls(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.inherit_acls)
}

// repeated .MumbleProto.ACL.ChanGroup groups = 3;
inline int ACL::_internal_groups_size() const {
  return groups_.size();
}
inline int ACL::groups_size() const {
  return _internal_groups_size();
}
inline void ACL::clear_groups() {
  groups_.Clear();
}
inline ::MumbleProto::ACL_ChanGroup* ACL::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.groups)
  return groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
ACL::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.groups)
  return &groups_;
}
inline const ::MumbleProto::ACL_ChanGroup& ACL::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const ::MumbleProto::ACL_ChanGroup& ACL::groups(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.groups)
  return _internal_groups(index);
}
inline ::MumbleProto::ACL_ChanGroup* ACL::_internal_add_groups() {
  return groups_.Add();
}
inline ::MumbleProto::ACL_ChanGroup* ACL::add_groups() {
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.groups)
  return _internal_add_groups();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
ACL::groups() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.groups)
  return groups_;
}

// repeated .MumbleProto.ACL.ChanACL acls = 4;
inline int ACL::_internal_acls_size() const {
  return acls_.size();
}
inline int ACL::acls_size() const {
  return _internal_acls_size();
}
inline void ACL::clear_acls() {
  acls_.Clear();
}
inline ::MumbleProto::ACL_ChanACL* ACL::mutable_acls(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.acls)
  return acls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
ACL::mutable_acls() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.acls)
  return &acls_;
}
inline const ::MumbleProto::ACL_ChanACL& ACL::_internal_acls(int index) const {
  return acls_.Get(index);
}
inline const ::MumbleProto::ACL_ChanACL& ACL::acls(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.acls)
  return _internal_acls(index);
}
inline ::MumbleProto::ACL_ChanACL* ACL::_internal_add_acls() {
  return acls_.Add();
}
inline ::MumbleProto::ACL_ChanACL* ACL::add_acls() {
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.acls)
  return _internal_add_acls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
ACL::acls() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.acls)
  return acls_;
}

// optional bool query = 5 [default = false];
inline bool ACL::_internal_has_query() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ACL::has_query() const {
  return _internal_has_query();
}
inline void ACL::clear_query() {
  query_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ACL::_internal_query() const {
  return query_;
}
inline bool ACL::query() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.query)
  return _internal_query();
}
inline void ACL::_internal_set_query(bool value) {
  _has_bits_[0] |= 0x00000002u;
  query_ = value;
}
inline void ACL::set_query(bool value) {
  _internal_set_query(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.query)
}

// -------------------------------------------------------------------

// QueryUsers

// repeated uint32 ids = 1;
inline int QueryUsers::_internal_ids_size() const {
  return ids_.size();
}
inline int QueryUsers::ids_size() const {
  return _internal_ids_size();
}
inline void QueryUsers::clear_ids() {
  ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueryUsers::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 QueryUsers::ids(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.QueryUsers.ids)
  return _internal_ids(index);
}
inline void QueryUsers::set_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.ids)
}
inline void QueryUsers::_internal_add_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  ids_.Add(value);
}
inline void QueryUsers::add_ids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_ids(value);
  // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
QueryUsers::_internal_ids() const {
  return ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
QueryUsers::ids() const {
  // @@protoc_insertion_point(field_list:MumbleProto.QueryUsers.ids)
  return _internal_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
QueryUsers::_internal_mutable_ids() {
  return &ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
QueryUsers::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.QueryUsers.ids)
  return _internal_mutable_ids();
}

// repeated string names = 2;
inline int QueryUsers::_internal_names_size() const {
  return names_.size();
}
inline int QueryUsers::names_size() const {
  return _internal_names_size();
}
inline void QueryUsers::clear_names() {
  names_.Clear();
}
inline std::string* QueryUsers::add_names() {
  // @@protoc_insertion_point(field_add_mutable:MumbleProto.QueryUsers.names)
  return _internal_add_names();
}
inline const std::string& QueryUsers::_internal_names(int index) const {
  return names_.Get(index);
}
inline const std::string& QueryUsers::names(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.QueryUsers.names)
  return _internal_names(index);
}
inline std::string* QueryUsers::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.QueryUsers.names)
  return names_.Mutable(index);
}
inline void QueryUsers::set_names(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.names)
  names_.Mutable(index)->assign(value);
}
inline void QueryUsers::set_names(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.names)
  names_.Mutable(index)->assign(std::move(value));
}
inline void QueryUsers::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MumbleProto.QueryUsers.names)
}
inline void QueryUsers::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.QueryUsers.names)
}
inline std::string* QueryUsers::_internal_add_names() {
  return names_.Add();
}
inline void QueryUsers::add_names(const std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.names)
}
inline void QueryUsers::add_names(std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.names)
}
inline void QueryUsers::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MumbleProto.QueryUsers.names)
}
inline void QueryUsers::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MumbleProto.QueryUsers.names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
QueryUsers::names() const {
  // @@protoc_insertion_point(field_list:MumbleProto.QueryUsers.names)
  return names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
QueryUsers::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.QueryUsers.names)
  return &names_;
}

// -------------------------------------------------------------------

// CryptSetup

// optional bytes key = 1;
inline bool CryptSetup::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CryptSetup::has_key() const {
  return _internal_has_key();
}
inline void CryptSetup::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CryptSetup::key() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.key)
  return _internal_key();
}
inline void CryptSetup::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.key)
}
inline std::string* CryptSetup::mutable_key() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.key)
  return _internal_mutable_key();
}
inline const std::string& CryptSetup::_internal_key() const {
  return key_.Get();
}
inline void CryptSetup::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CryptSetup::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.CryptSetup.key)
}
inline void CryptSetup::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.key)
}
inline void CryptSetup::set_key(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.key)
}
inline std::string* CryptSetup::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CryptSetup::release_key() {
  // @@protoc_insertion_point(field_release:MumbleProto.CryptSetup.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CryptSetup::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.key)
}

// optional bytes client_nonce = 2;
inline bool CryptSetup::_internal_has_client_nonce() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CryptSetup::has_client_nonce() const {
  return _internal_has_client_nonce();
}
inline void CryptSetup::clear_client_nonce() {
  client_nonce_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CryptSetup::client_nonce() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.client_nonce)
  return _internal_client_nonce();
}
inline void CryptSetup::set_client_nonce(const std::string& value) {
  _internal_set_client_nonce(value);
  // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.client_nonce)
}
inline std::string* CryptSetup::mutable_client_nonce() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.client_nonce)
  return _internal_mutable_client_nonce();
}
inline const std::string& CryptSetup::_internal_client_nonce() const {
  return client_nonce_.Get();
}
inline void CryptSetup::_internal_set_client_nonce(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  client_nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CryptSetup::set_client_nonce(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  client_nonce_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.CryptSetup.client_nonce)
}
inline void CryptSetup::set_client_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  client_nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.client_nonce)
}
inline void CryptSetup::set_client_nonce(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  client_nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.client_nonce)
}
inline std::string* CryptSetup::_internal_mutable_client_nonce() {
  _has_bits_[0] |= 0x00000002u;
  return client_nonce_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CryptSetup::release_client_nonce() {
  // @@protoc_insertion_point(field_release:MumbleProto.CryptSetup.client_nonce)
  if (!_internal_has_client_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return client_nonce_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CryptSetup::set_allocated_client_nonce(std::string* client_nonce) {
  if (client_nonce != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_nonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_nonce,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.client_nonce)
}

// optional bytes server_nonce = 3;
inline bool CryptSetup::_internal_has_server_nonce() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CryptSetup::has_server_nonce() const {
  return _internal_has_server_nonce();
}
inline void CryptSetup::clear_server_nonce() {
  server_nonce_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CryptSetup::server_nonce() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.server_nonce)
  return _internal_server_nonce();
}
inline void CryptSetup::set_server_nonce(const std::string& value) {
  _internal_set_server_nonce(value);
  // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.server_nonce)
}
inline std::string* CryptSetup::mutable_server_nonce() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.server_nonce)
  return _internal_mutable_server_nonce();
}
inline const std::string& CryptSetup::_internal_server_nonce() const {
  return server_nonce_.Get();
}
inline void CryptSetup::_internal_set_server_nonce(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  server_nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CryptSetup::set_server_nonce(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  server_nonce_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.CryptSetup.server_nonce)
}
inline void CryptSetup::set_server_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  server_nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.server_nonce)
}
inline void CryptSetup::set_server_nonce(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  server_nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.server_nonce)
}
inline std::string* CryptSetup::_internal_mutable_server_nonce() {
  _has_bits_[0] |= 0x00000004u;
  return server_nonce_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CryptSetup::release_server_nonce() {
  // @@protoc_insertion_point(field_release:MumbleProto.CryptSetup.server_nonce)
  if (!_internal_has_server_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return server_nonce_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CryptSetup::set_allocated_server_nonce(std::string* server_nonce) {
  if (server_nonce != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  server_nonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_nonce,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.server_nonce)
}

// -------------------------------------------------------------------

// ContextActionModify

// required string action = 1;
inline bool ContextActionModify::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContextActionModify::has_action() const {
  return _internal_has_action();
}
inline void ContextActionModify::clear_action() {
  action_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContextActionModify::action() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.action)
  return _internal_action();
}
inline void ContextActionModify::set_action(const std::string& value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.action)
}
inline std::string* ContextActionModify::mutable_action() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ContextActionModify.action)
  return _internal_mutable_action();
}
inline const std::string& ContextActionModify::_internal_action() const {
  return action_.Get();
}
inline void ContextActionModify::_internal_set_action(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ContextActionModify::set_action(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  action_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ContextActionModify.action)
}
inline void ContextActionModify::set_action(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ContextActionModify.action)
}
inline void ContextActionModify::set_action(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextActionModify.action)
}
inline std::string* ContextActionModify::_internal_mutable_action() {
  _has_bits_[0] |= 0x00000001u;
  return action_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ContextActionModify::release_action() {
  // @@protoc_insertion_point(field_release:MumbleProto.ContextActionModify.action)
  if (!_internal_has_action()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return action_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContextActionModify::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextActionModify.action)
}

// optional string text = 2;
inline bool ContextActionModify::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContextActionModify::has_text() const {
  return _internal_has_text();
}
inline void ContextActionModify::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContextActionModify::text() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.text)
  return _internal_text();
}
inline void ContextActionModify::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.text)
}
inline std::string* ContextActionModify::mutable_text() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ContextActionModify.text)
  return _internal_mutable_text();
}
inline const std::string& ContextActionModify::_internal_text() const {
  return text_.Get();
}
inline void ContextActionModify::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ContextActionModify::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ContextActionModify.text)
}
inline void ContextActionModify::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ContextActionModify.text)
}
inline void ContextActionModify::set_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextActionModify.text)
}
inline std::string* ContextActionModify::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000002u;
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ContextActionModify::release_text() {
  // @@protoc_insertion_point(field_release:MumbleProto.ContextActionModify.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContextActionModify::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextActionModify.text)
}

// optional uint32 context = 3;
inline bool ContextActionModify::_internal_has_context() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContextActionModify::has_context() const {
  return _internal_has_context();
}
inline void ContextActionModify::clear_context() {
  context_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContextActionModify::_internal_context() const {
  return context_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContextActionModify::context() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.context)
  return _internal_context();
}
inline void ContextActionModify::_internal_set_context(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  context_ = value;
}
inline void ContextActionModify::set_context(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_context(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.context)
}

// optional .MumbleProto.ContextActionModify.Operation operation = 4;
inline bool ContextActionModify::_internal_has_operation() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ContextActionModify::has_operation() const {
  return _internal_has_operation();
}
inline void ContextActionModify::clear_operation() {
  operation_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::MumbleProto::ContextActionModify_Operation ContextActionModify::_internal_operation() const {
  return static_cast< ::MumbleProto::ContextActionModify_Operation >(operation_);
}
inline ::MumbleProto::ContextActionModify_Operation ContextActionModify::operation() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.operation)
  return _internal_operation();
}
inline void ContextActionModify::_internal_set_operation(::MumbleProto::ContextActionModify_Operation value) {
  assert(::MumbleProto::ContextActionModify_Operation_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  operation_ = value;
}
inline void ContextActionModify::set_operation(::MumbleProto::ContextActionModify_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.operation)
}

// -------------------------------------------------------------------

// ContextAction

// optional uint32 session = 1;
inline bool ContextAction::_internal_has_session() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ContextAction::has_session() const {
  return _internal_has_session();
}
inline void ContextAction::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContextAction::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContextAction::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.session)
  return _internal_session();
}
inline void ContextAction::_internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  session_ = value;
}
inline void ContextAction::set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.session)
}

// optional uint32 channel_id = 2;
inline bool ContextAction::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ContextAction::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void ContextAction::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContextAction::_internal_channel_id() const {
  return channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ContextAction::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.channel_id)
  return _internal_channel_id();
}
inline void ContextAction::_internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  channel_id_ = value;
}
inline void ContextAction::set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.channel_id)
}

// required string action = 3;
inline bool ContextAction::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ContextAction::has_action() const {
  return _internal_has_action();
}
inline void ContextAction::clear_action() {
  action_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContextAction::action() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.action)
  return _internal_action();
}
inline void ContextAction::set_action(const std::string& value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.action)
}
inline std::string* ContextAction::mutable_action() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ContextAction.action)
  return _internal_mutable_action();
}
inline const std::string& ContextAction::_internal_action() const {
  return action_.Get();
}
inline void ContextAction::_internal_set_action(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ContextAction::set_action(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  action_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ContextAction.action)
}
inline void ContextAction::set_action(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ContextAction.action)
}
inline void ContextAction::set_action(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  action_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextAction.action)
}
inline std::string* ContextAction::_internal_mutable_action() {
  _has_bits_[0] |= 0x00000001u;
  return action_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ContextAction::release_action() {
  // @@protoc_insertion_point(field_release:MumbleProto.ContextAction.action)
  if (!_internal_has_action()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return action_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ContextAction::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextAction.action)
}

// -------------------------------------------------------------------

// UserList_User

// required uint32 user_id = 1;
inline bool UserList_User::_internal_has_user_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserList_User::has_user_id() const {
  return _internal_has_user_id();
}
inline void UserList_User::clear_user_id() {
  user_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserList_User::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserList_User::user_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.user_id)
  return _internal_user_id();
}
inline void UserList_User::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  user_id_ = value;
}
inline void UserList_User::set_user_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.user_id)
}

// optional string name = 2;
inline bool UserList_User::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserList_User::has_name() const {
  return _internal_has_name();
}
inline void UserList_User::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserList_User::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.name)
  return _internal_name();
}
inline void UserList_User::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.name)
}
inline std::string* UserList_User::mutable_name() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.User.name)
  return _internal_mutable_name();
}
inline const std::string& UserList_User::_internal_name() const {
  return name_.Get();
}
inline void UserList_User::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserList_User::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserList.User.name)
}
inline void UserList_User::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserList.User.name)
}
inline void UserList_User::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserList.User.name)
}
inline std::string* UserList_User::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserList_User::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserList.User.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserList_User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserList.User.name)
}

// optional string last_seen = 3;
inline bool UserList_User::_internal_has_last_seen() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserList_User::has_last_seen() const {
  return _internal_has_last_seen();
}
inline void UserList_User::clear_last_seen() {
  last_seen_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserList_User::last_seen() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.last_seen)
  return _internal_last_seen();
}
inline void UserList_User::set_last_seen(const std::string& value) {
  _internal_set_last_seen(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.last_seen)
}
inline std::string* UserList_User::mutable_last_seen() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.User.last_seen)
  return _internal_mutable_last_seen();
}
inline const std::string& UserList_User::_internal_last_seen() const {
  return last_seen_.Get();
}
inline void UserList_User::_internal_set_last_seen(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  last_seen_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserList_User::set_last_seen(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  last_seen_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserList.User.last_seen)
}
inline void UserList_User::set_last_seen(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  last_seen_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserList.User.last_seen)
}
inline void UserList_User::set_last_seen(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  last_seen_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserList.User.last_seen)
}
inline std::string* UserList_User::_internal_mutable_last_seen() {
  _has_bits_[0] |= 0x00000002u;
  return last_seen_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserList_User::release_last_seen() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserList.User.last_seen)
  if (!_internal_has_last_seen()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return last_seen_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserList_User::set_allocated_last_seen(std::string* last_seen) {
  if (last_seen != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  last_seen_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_seen,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserList.User.last_seen)
}

// optional uint32 last_channel = 4;
inline bool UserList_User::_internal_has_last_channel() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserList_User::has_last_channel() const {
  return _internal_has_last_channel();
}
inline void UserList_User::clear_last_channel() {
  last_channel_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserList_User::_internal_last_channel() const {
  return last_channel_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserList_User::last_channel() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.last_channel)
  return _internal_last_channel();
}
inline void UserList_User::_internal_set_last_channel(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  last_channel_ = value;
}
inline void UserList_User::set_last_channel(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_last_channel(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.last_channel)
}

// -------------------------------------------------------------------

// UserList

// repeated .MumbleProto.UserList.User users = 1;
inline int UserList::_internal_users_size() const {
  return users_.size();
}
inline int UserList::users_size() const {
  return _internal_users_size();
}
inline void UserList::clear_users() {
  users_.Clear();
}
inline ::MumbleProto::UserList_User* UserList::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::UserList_User >*
UserList::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserList.users)
  return &users_;
}
inline const ::MumbleProto::UserList_User& UserList::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::MumbleProto::UserList_User& UserList::users(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.users)
  return _internal_users(index);
}
inline ::MumbleProto::UserList_User* UserList::_internal_add_users() {
  return users_.Add();
}
inline ::MumbleProto::UserList_User* UserList::add_users() {
  // @@protoc_insertion_point(field_add:MumbleProto.UserList.users)
  return _internal_add_users();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::UserList_User >&
UserList::users() const {
  // @@protoc_insertion_point(field_list:MumbleProto.UserList.users)
  return users_;
}

// -------------------------------------------------------------------

// VoiceTarget_Target

// repeated uint32 session = 1;
inline int VoiceTarget_Target::_internal_session_size() const {
  return session_.size();
}
inline int VoiceTarget_Target::session_size() const {
  return _internal_session_size();
}
inline void VoiceTarget_Target::clear_session() {
  session_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VoiceTarget_Target::_internal_session(int index) const {
  return session_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VoiceTarget_Target::session(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.session)
  return _internal_session(index);
}
inline void VoiceTarget_Target::set_session(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  session_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.session)
}
inline void VoiceTarget_Target::_internal_add_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  session_.Add(value);
}
inline void VoiceTarget_Target::add_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_session(value);
  // @@protoc_insertion_point(field_add:MumbleProto.VoiceTarget.Target.session)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
VoiceTarget_Target::_internal_session() const {
  return session_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
VoiceTarget_Target::session() const {
  // @@protoc_insertion_point(field_list:MumbleProto.VoiceTarget.Target.session)
  return _internal_session();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
VoiceTarget_Target::_internal_mutable_session() {
  return &session_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
VoiceTarget_Target::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.VoiceTarget.Target.session)
  return _internal_mutable_session();
}

// optional uint32 channel_id = 2;
inline bool VoiceTarget_Target::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VoiceTarget_Target::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void VoiceTarget_Target::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VoiceTarget_Target::_internal_channel_id() const {
  return channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VoiceTarget_Target::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.channel_id)
  return _internal_channel_id();
}
inline void VoiceTarget_Target::_internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  channel_id_ = value;
}
inline void VoiceTarget_Target::set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.channel_id)
}

// optional string group = 3;
inline bool VoiceTarget_Target::_internal_has_group() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VoiceTarget_Target::has_group() const {
  return _internal_has_group();
}
inline void VoiceTarget_Target::clear_group() {
  group_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VoiceTarget_Target::group() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.group)
  return _internal_group();
}
inline void VoiceTarget_Target::set_group(const std::string& value) {
  _internal_set_group(value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.group)
}
inline std::string* VoiceTarget_Target::mutable_group() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.VoiceTarget.Target.group)
  return _internal_mutable_group();
}
inline const std::string& VoiceTarget_Target::_internal_group() const {
  return group_.Get();
}
inline void VoiceTarget_Target::_internal_set_group(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VoiceTarget_Target::set_group(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.VoiceTarget.Target.group)
}
inline void VoiceTarget_Target::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.VoiceTarget.Target.group)
}
inline void VoiceTarget_Target::set_group(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.VoiceTarget.Target.group)
}
inline std::string* VoiceTarget_Target::_internal_mutable_group() {
  _has_bits_[0] |= 0x00000001u;
  return group_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VoiceTarget_Target::release_group() {
  // @@protoc_insertion_point(field_release:MumbleProto.VoiceTarget.Target.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return group_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VoiceTarget_Target::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.VoiceTarget.Target.group)
}

// optional bool links = 4 [default = false];
inline bool VoiceTarget_Target::_internal_has_links() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VoiceTarget_Target::has_links() const {
  return _internal_has_links();
}
inline void VoiceTarget_Target::clear_links() {
  links_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool VoiceTarget_Target::_internal_links() const {
  return links_;
}
inline bool VoiceTarget_Target::links() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.links)
  return _internal_links();
}
inline void VoiceTarget_Target::_internal_set_links(bool value) {
  _has_bits_[0] |= 0x00000004u;
  links_ = value;
}
inline void VoiceTarget_Target::set_links(bool value) {
  _internal_set_links(value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.links)
}

// optional bool children = 5 [default = false];
inline bool VoiceTarget_Target::_internal_has_children() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VoiceTarget_Target::has_children() const {
  return _internal_has_children();
}
inline void VoiceTarget_Target::clear_children() {
  children_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool VoiceTarget_Target::_internal_children() const {
  return children_;
}
inline bool VoiceTarget_Target::children() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.children)
  return _internal_children();
}
inline void VoiceTarget_Target::_internal_set_children(bool value) {
  _has_bits_[0] |= 0x00000008u;
  children_ = value;
}
inline void VoiceTarget_Target::set_children(bool value) {
  _internal_set_children(value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.children)
}

// -------------------------------------------------------------------

// VoiceTarget

// optional uint32 id = 1;
inline bool VoiceTarget::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VoiceTarget::has_id() const {
  return _internal_has_id();
}
inline void VoiceTarget::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VoiceTarget::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VoiceTarget::id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.id)
  return _internal_id();
}
inline void VoiceTarget::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void VoiceTarget::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.id)
}

// repeated .MumbleProto.VoiceTarget.Target targets = 2;
inline int VoiceTarget::_internal_targets_size() const {
  return targets_.size();
}
inline int VoiceTarget::targets_size() const {
  return _internal_targets_size();
}
inline void VoiceTarget::clear_targets() {
  targets_.Clear();
}
inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.VoiceTarget.targets)
  return targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
VoiceTarget::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.VoiceTarget.targets)
  return &targets_;
}
inline const ::MumbleProto::VoiceTarget_Target& VoiceTarget::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const ::MumbleProto::VoiceTarget_Target& VoiceTarget::targets(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.targets)
  return _internal_targets(index);
}
inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::_internal_add_targets() {
  return targets_.Add();
}
inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::add_targets() {
  // @@protoc_insertion_point(field_add:MumbleProto.VoiceTarget.targets)
  return _internal_add_targets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
VoiceTarget::targets() const {
  // @@protoc_insertion_point(field_list:MumbleProto.VoiceTarget.targets)
  return targets_;
}

// -------------------------------------------------------------------

// PermissionQuery

// optional uint32 channel_id = 1;
inline bool PermissionQuery::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PermissionQuery::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void PermissionQuery::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionQuery::_internal_channel_id() const {
  return channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionQuery::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.channel_id)
  return _internal_channel_id();
}
inline void PermissionQuery::_internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_ = value;
}
inline void PermissionQuery::set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.channel_id)
}

// optional uint32 permissions = 2;
inline bool PermissionQuery::_internal_has_permissions() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PermissionQuery::has_permissions() const {
  return _internal_has_permissions();
}
inline void PermissionQuery::clear_permissions() {
  permissions_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionQuery::_internal_permissions() const {
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PermissionQuery::permissions() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.permissions)
  return _internal_permissions();
}
inline void PermissionQuery::_internal_set_permissions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  permissions_ = value;
}
inline void PermissionQuery::set_permissions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_permissions(value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.permissions)
}

// optional bool flush = 3 [default = false];
inline bool PermissionQuery::_internal_has_flush() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PermissionQuery::has_flush() const {
  return _internal_has_flush();
}
inline void PermissionQuery::clear_flush() {
  flush_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PermissionQuery::_internal_flush() const {
  return flush_;
}
inline bool PermissionQuery::flush() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.flush)
  return _internal_flush();
}
inline void PermissionQuery::_internal_set_flush(bool value) {
  _has_bits_[0] |= 0x00000004u;
  flush_ = value;
}
inline void PermissionQuery::set_flush(bool value) {
  _internal_set_flush(value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.flush)
}

// -------------------------------------------------------------------

// CodecVersion

// required int32 alpha = 1;
inline bool CodecVersion::_internal_has_alpha() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CodecVersion::has_alpha() const {
  return _internal_has_alpha();
}
inline void CodecVersion::clear_alpha() {
  alpha_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CodecVersion::_internal_alpha() const {
  return alpha_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CodecVersion::alpha() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.alpha)
  return _internal_alpha();
}
inline void CodecVersion::_internal_set_alpha(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  alpha_ = value;
}
inline void CodecVersion::set_alpha(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_alpha(value);
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.alpha)
}

// required int32 beta = 2;
inline bool CodecVersion::_internal_has_beta() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CodecVersion::has_beta() const {
  return _internal_has_beta();
}
inline void CodecVersion::clear_beta() {
  beta_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CodecVersion::_internal_beta() const {
  return beta_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CodecVersion::beta() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.beta)
  return _internal_beta();
}
inline void CodecVersion::_internal_set_beta(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  beta_ = value;
}
inline void CodecVersion::set_beta(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_beta(value);
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.beta)
}

// required bool prefer_alpha = 3 [default = true];
inline bool CodecVersion::_internal_has_prefer_alpha() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CodecVersion::has_prefer_alpha() const {
  return _internal_has_prefer_alpha();
}
inline void CodecVersion::clear_prefer_alpha() {
  prefer_alpha_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CodecVersion::_internal_prefer_alpha() const {
  return prefer_alpha_;
}
inline bool CodecVersion::prefer_alpha() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.prefer_alpha)
  return _internal_prefer_alpha();
}
inline void CodecVersion::_internal_set_prefer_alpha(bool value) {
  _has_bits_[0] |= 0x00000008u;
  prefer_alpha_ = value;
}
inline void CodecVersion::set_prefer_alpha(bool value) {
  _internal_set_prefer_alpha(value);
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.prefer_alpha)
}

// optional bool opus = 4 [default = false];
inline bool CodecVersion::_internal_has_opus() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CodecVersion::has_opus() const {
  return _internal_has_opus();
}
inline void CodecVersion::clear_opus() {
  opus_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CodecVersion::_internal_opus() const {
  return opus_;
}
inline bool CodecVersion::opus() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.opus)
  return _internal_opus();
}
inline void CodecVersion::_internal_set_opus(bool value) {
  _has_bits_[0] |= 0x00000004u;
  opus_ = value;
}
inline void CodecVersion::set_opus(bool value) {
  _internal_set_opus(value);
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.opus)
}

// -------------------------------------------------------------------

// UserStats_Stats

// optional uint32 good = 1;
inline bool UserStats_Stats::_internal_has_good() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserStats_Stats::has_good() const {
  return _internal_has_good();
}
inline void UserStats_Stats::clear_good() {
  good_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats_Stats::_internal_good() const {
  return good_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats_Stats::good() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.good)
  return _internal_good();
}
inline void UserStats_Stats::_internal_set_good(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  good_ = value;
}
inline void UserStats_Stats::set_good(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_good(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.good)
}

// optional uint32 late = 2;
inline bool UserStats_Stats::_internal_has_late() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserStats_Stats::has_late() const {
  return _internal_has_late();
}
inline void UserStats_Stats::clear_late() {
  late_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats_Stats::_internal_late() const {
  return late_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats_Stats::late() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.late)
  return _internal_late();
}
inline void UserStats_Stats::_internal_set_late(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  late_ = value;
}
inline void UserStats_Stats::set_late(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_late(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.late)
}

// optional uint32 lost = 3;
inline bool UserStats_Stats::_internal_has_lost() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserStats_Stats::has_lost() const {
  return _internal_has_lost();
}
inline void UserStats_Stats::clear_lost() {
  lost_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats_Stats::_internal_lost() const {
  return lost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats_Stats::lost() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.lost)
  return _internal_lost();
}
inline void UserStats_Stats::_internal_set_lost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  lost_ = value;
}
inline void UserStats_Stats::set_lost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lost(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.lost)
}

// optional uint32 resync = 4;
inline bool UserStats_Stats::_internal_has_resync() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserStats_Stats::has_resync() const {
  return _internal_has_resync();
}
inline void UserStats_Stats::clear_resync() {
  resync_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats_Stats::_internal_resync() const {
  return resync_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats_Stats::resync() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.resync)
  return _internal_resync();
}
inline void UserStats_Stats::_internal_set_resync(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  resync_ = value;
}
inline void UserStats_Stats::set_resync(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_resync(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.resync)
}

// -------------------------------------------------------------------

// UserStats

// optional uint32 session = 1;
inline bool UserStats::_internal_has_session() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserStats::has_session() const {
  return _internal_has_session();
}
inline void UserStats::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.session)
  return _internal_session();
}
inline void UserStats::_internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  session_ = value;
}
inline void UserStats::set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.session)
}

// optional bool stats_only = 2 [default = false];
inline bool UserStats::_internal_has_stats_only() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UserStats::has_stats_only() const {
  return _internal_has_stats_only();
}
inline void UserStats::clear_stats_only() {
  stats_only_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool UserStats::_internal_stats_only() const {
  return stats_only_;
}
inline bool UserStats::stats_only() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.stats_only)
  return _internal_stats_only();
}
inline void UserStats::_internal_set_stats_only(bool value) {
  _has_bits_[0] |= 0x00000800u;
  stats_only_ = value;
}
inline void UserStats::set_stats_only(bool value) {
  _internal_set_stats_only(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.stats_only)
}

// repeated bytes certificates = 3;
inline int UserStats::_internal_certificates_size() const {
  return certificates_.size();
}
inline int UserStats::certificates_size() const {
  return _internal_certificates_size();
}
inline void UserStats::clear_certificates() {
  certificates_.Clear();
}
inline std::string* UserStats::add_certificates() {
  // @@protoc_insertion_point(field_add_mutable:MumbleProto.UserStats.certificates)
  return _internal_add_certificates();
}
inline const std::string& UserStats::_internal_certificates(int index) const {
  return certificates_.Get(index);
}
inline const std::string& UserStats::certificates(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.certificates)
  return _internal_certificates(index);
}
inline std::string* UserStats::mutable_certificates(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.certificates)
  return certificates_.Mutable(index);
}
inline void UserStats::set_certificates(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.certificates)
  certificates_.Mutable(index)->assign(value);
}
inline void UserStats::set_certificates(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.certificates)
  certificates_.Mutable(index)->assign(std::move(value));
}
inline void UserStats::set_certificates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserStats.certificates)
}
inline void UserStats::set_certificates(int index, const void* value, size_t size) {
  certificates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserStats.certificates)
}
inline std::string* UserStats::_internal_add_certificates() {
  return certificates_.Add();
}
inline void UserStats::add_certificates(const std::string& value) {
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MumbleProto.UserStats.certificates)
}
inline void UserStats::add_certificates(std::string&& value) {
  certificates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MumbleProto.UserStats.certificates)
}
inline void UserStats::add_certificates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MumbleProto.UserStats.certificates)
}
inline void UserStats::add_certificates(const void* value, size_t size) {
  certificates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MumbleProto.UserStats.certificates)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserStats::certificates() const {
  // @@protoc_insertion_point(field_list:MumbleProto.UserStats.certificates)
  return certificates_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserStats::mutable_certificates() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserStats.certificates)
  return &certificates_;
}

// optional .MumbleProto.UserStats.Stats from_client = 4;
inline bool UserStats::_internal_has_from_client() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || from_client_ != nullptr);
  return value;
}
inline bool UserStats::has_from_client() const {
  return _internal_has_from_client();
}
inline void UserStats::clear_from_client() {
  if (from_client_ != nullptr) from_client_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::MumbleProto::UserStats_Stats& UserStats::_internal_from_client() const {
  const ::MumbleProto::UserStats_Stats* p = from_client_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MumbleProto::UserStats_Stats*>(
      &::MumbleProto::_UserStats_Stats_default_instance_);
}
inline const ::MumbleProto::UserStats_Stats& UserStats::from_client() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.from_client)
  return _internal_from_client();
}
inline void UserStats::unsafe_arena_set_allocated_from_client(
    ::MumbleProto::UserStats_Stats* from_client) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_client_);
  }
  from_client_ = from_client;
  if (from_client) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MumbleProto.UserStats.from_client)
}
inline ::MumbleProto::UserStats_Stats* UserStats::release_from_client() {
  _has_bits_[0] &= ~0x00000002u;
  ::MumbleProto::UserStats_Stats* temp = from_client_;
  from_client_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MumbleProto::UserStats_Stats* UserStats::unsafe_arena_release_from_client() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserStats.from_client)
  _has_bits_[0] &= ~0x00000002u;
  ::MumbleProto::UserStats_Stats* temp = from_client_;
  from_client_ = nullptr;
  return temp;
}
inline ::MumbleProto::UserStats_Stats* UserStats::_internal_mutable_from_client() {
  _has_bits_[0] |= 0x00000002u;
  if (from_client_ == nullptr) {
    auto* p = CreateMaybeMessage<::MumbleProto::UserStats_Stats>(GetArena());
    from_client_ = p;
  }
  return from_client_;
}
inline ::MumbleProto::UserStats_Stats* UserStats::mutable_from_client() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.from_client)
  return _internal_mutable_from_client();
}
inline void UserStats::set_allocated_from_client(::MumbleProto::UserStats_Stats* from_client) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete from_client_;
  }
  if (from_client) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(from_client);
    if (message_arena != submessage_arena) {
      from_client = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from_client, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  from_client_ = from_client;
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.from_client)
}

// optional .MumbleProto.UserStats.Stats from_server = 5;
inline bool UserStats::_internal_has_from_server() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || from_server_ != nullptr);
  return value;
}
inline bool UserStats::has_from_server() const {
  return _internal_has_from_server();
}
inline void UserStats::clear_from_server() {
  if (from_server_ != nullptr) from_server_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::MumbleProto::UserStats_Stats& UserStats::_internal_from_server() const {
  const ::MumbleProto::UserStats_Stats* p = from_server_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MumbleProto::UserStats_Stats*>(
      &::MumbleProto::_UserStats_Stats_default_instance_);
}
inline const ::MumbleProto::UserStats_Stats& UserStats::from_server() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.from_server)
  return _internal_from_server();
}
inline void UserStats::unsafe_arena_set_allocated_from_server(
    ::MumbleProto::UserStats_Stats* from_server) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(from_server_);
  }
  from_server_ = from_server;
  if (from_server) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MumbleProto.UserStats.from_server)
}
inline ::MumbleProto::UserStats_Stats* UserStats::release_from_server() {
  _has_bits_[0] &= ~0x00000004u;
  ::MumbleProto::UserStats_Stats* temp = from_server_;
  from_server_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MumbleProto::UserStats_Stats* UserStats::unsafe_arena_release_from_server() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserStats.from_server)
  _has_bits_[0] &= ~0x00000004u;
  ::MumbleProto::UserStats_Stats* temp = from_server_;
  from_server_ = nullptr;
  return temp;
}
inline ::MumbleProto::UserStats_Stats* UserStats::_internal_mutable_from_server() {
  _has_bits_[0] |= 0x00000004u;
  if (from_server_ == nullptr) {
    auto* p = CreateMaybeMessage<::MumbleProto::UserStats_Stats>(GetArena());
    from_server_ = p;
  }
  return from_server_;
}
inline ::MumbleProto::UserStats_Stats* UserStats::mutable_from_server() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.from_server)
  return _internal_mutable_from_server();
}
inline void UserStats::set_allocated_from_server(::MumbleProto::UserStats_Stats* from_server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete from_server_;
  }
  if (from_server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(from_server);
    if (message_arena != submessage_arena) {
      from_server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from_server, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  from_server_ = from_server;
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.from_server)
}

// optional uint32 udp_packets = 6;
inline bool UserStats::_internal_has_udp_packets() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserStats::has_udp_packets() const {
  return _internal_has_udp_packets();
}
inline void UserStats::clear_udp_packets() {
  udp_packets_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::_internal_udp_packets() const {
  return udp_packets_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::udp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_packets)
  return _internal_udp_packets();
}
inline void UserStats::_internal_set_udp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  udp_packets_ = value;
}
inline void UserStats::set_udp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_udp_packets(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_packets)
}

// optional uint32 tcp_packets = 7;
inline bool UserStats::_internal_has_tcp_packets() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserStats::has_tcp_packets() const {
  return _internal_has_tcp_packets();
}
inline void UserStats::clear_tcp_packets() {
  tcp_packets_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::_internal_tcp_packets() const {
  return tcp_packets_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::tcp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_packets)
  return _internal_tcp_packets();
}
inline void UserStats::_internal_set_tcp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  tcp_packets_ = value;
}
inline void UserStats::set_tcp_packets(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tcp_packets(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_packets)
}

// optional float udp_ping_avg = 8;
inline bool UserStats::_internal_has_udp_ping_avg() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserStats::has_udp_ping_avg() const {
  return _internal_has_udp_ping_avg();
}
inline void UserStats::clear_udp_ping_avg() {
  udp_ping_avg_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float UserStats::_internal_udp_ping_avg() const {
  return udp_ping_avg_;
}
inline float UserStats::udp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_ping_avg)
  return _internal_udp_ping_avg();
}
inline void UserStats::_internal_set_udp_ping_avg(float value) {
  _has_bits_[0] |= 0x00000080u;
  udp_ping_avg_ = value;
}
inline void UserStats::set_udp_ping_avg(float value) {
  _internal_set_udp_ping_avg(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_ping_avg)
}

// optional float udp_ping_var = 9;
inline bool UserStats::_internal_has_udp_ping_var() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserStats::has_udp_ping_var() const {
  return _internal_has_udp_ping_var();
}
inline void UserStats::clear_udp_ping_var() {
  udp_ping_var_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float UserStats::_internal_udp_ping_var() const {
  return udp_ping_var_;
}
inline float UserStats::udp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_ping_var)
  return _internal_udp_ping_var();
}
inline void UserStats::_internal_set_udp_ping_var(float value) {
  _has_bits_[0] |= 0x00000100u;
  udp_ping_var_ = value;
}
inline void UserStats::set_udp_ping_var(float value) {
  _internal_set_udp_ping_var(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_ping_var)
}

// optional float tcp_ping_avg = 10;
inline bool UserStats::_internal_has_tcp_ping_avg() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UserStats::has_tcp_ping_avg() const {
  return _internal_has_tcp_ping_avg();
}
inline void UserStats::clear_tcp_ping_avg() {
  tcp_ping_avg_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float UserStats::_internal_tcp_ping_avg() const {
  return tcp_ping_avg_;
}
inline float UserStats::tcp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_ping_avg)
  return _internal_tcp_ping_avg();
}
inline void UserStats::_internal_set_tcp_ping_avg(float value) {
  _has_bits_[0] |= 0x00000200u;
  tcp_ping_avg_ = value;
}
inline void UserStats::set_tcp_ping_avg(float value) {
  _internal_set_tcp_ping_avg(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_ping_avg)
}

// optional float tcp_ping_var = 11;
inline bool UserStats::_internal_has_tcp_ping_var() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UserStats::has_tcp_ping_var() const {
  return _internal_has_tcp_ping_var();
}
inline void UserStats::clear_tcp_ping_var() {
  tcp_ping_var_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float UserStats::_internal_tcp_ping_var() const {
  return tcp_ping_var_;
}
inline float UserStats::tcp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_ping_var)
  return _internal_tcp_ping_var();
}
inline void UserStats::_internal_set_tcp_ping_var(float value) {
  _has_bits_[0] |= 0x00000400u;
  tcp_ping_var_ = value;
}
inline void UserStats::set_tcp_ping_var(float value) {
  _internal_set_tcp_ping_var(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_ping_var)
}

// optional .MumbleProto.Version version = 12;
inline bool UserStats::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || version_ != nullptr);
  return value;
}
inline bool UserStats::has_version() const {
  return _internal_has_version();
}
inline void UserStats::clear_version() {
  if (version_ != nullptr) version_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::MumbleProto::Version& UserStats::_internal_version() const {
  const ::MumbleProto::Version* p = version_;
  return p != nullptr ? *p : *reinterpret_cast<const ::MumbleProto::Version*>(
      &::MumbleProto::_Version_default_instance_);
}
inline const ::MumbleProto::Version& UserStats::version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.version)
  return _internal_version();
}
inline void UserStats::unsafe_arena_set_allocated_version(
    ::MumbleProto::Version* version) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  version_ = version;
  if (version) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MumbleProto.UserStats.version)
}
inline ::MumbleProto::Version* UserStats::release_version() {
  _has_bits_[0] &= ~0x00000008u;
  ::MumbleProto::Version* temp = version_;
  version_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::MumbleProto::Version* UserStats::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserStats.version)
  _has_bits_[0] &= ~0x00000008u;
  ::MumbleProto::Version* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::MumbleProto::Version* UserStats::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000008u;
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::MumbleProto::Version>(GetArena());
    version_ = p;
  }
  return version_;
}
inline ::MumbleProto::Version* UserStats::mutable_version() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.version)
  return _internal_mutable_version();
}
inline void UserStats::set_allocated_version(::MumbleProto::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.version)
}

// repeated int32 celt_versions = 13;
inline int UserStats::_internal_celt_versions_size() const {
  return celt_versions_.size();
}
inline int UserStats::celt_versions_size() const {
  return _internal_celt_versions_size();
}
inline void UserStats::clear_celt_versions() {
  celt_versions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserStats::_internal_celt_versions(int index) const {
  return celt_versions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserStats::celt_versions(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.celt_versions)
  return _internal_celt_versions(index);
}
inline void UserStats::set_celt_versions(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  celt_versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.celt_versions)
}
inline void UserStats::_internal_add_celt_versions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  celt_versions_.Add(value);
}
inline void UserStats::add_celt_versions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_celt_versions(value);
  // @@protoc_insertion_point(field_add:MumbleProto.UserStats.celt_versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
UserStats::_internal_celt_versions() const {
  return celt_versions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
UserStats::celt_versions() const {
  // @@protoc_insertion_point(field_list:MumbleProto.UserStats.celt_versions)
  return _internal_celt_versions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
UserStats::_internal_mutable_celt_versions() {
  return &celt_versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
UserStats::mutable_celt_versions() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserStats.celt_versions)
  return _internal_mutable_celt_versions();
}

// optional bytes address = 14;
inline bool UserStats::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserStats::has_address() const {
  return _internal_has_address();
}
inline void UserStats::clear_address() {
  address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserStats::address() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.address)
  return _internal_address();
}
inline void UserStats::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.address)
}
inline std::string* UserStats::mutable_address() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.address)
  return _internal_mutable_address();
}
inline const std::string& UserStats::_internal_address() const {
  return address_.Get();
}
inline void UserStats::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UserStats::set_address(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserStats.address)
}
inline void UserStats::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserStats.address)
}
inline void UserStats::set_address(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserStats.address)
}
inline std::string* UserStats::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UserStats::release_address() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserStats.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UserStats::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.address)
}

// optional uint32 bandwidth = 15;
inline bool UserStats::_internal_has_bandwidth() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool UserStats::has_bandwidth() const {
  return _internal_has_bandwidth();
}
inline void UserStats::clear_bandwidth() {
  bandwidth_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::_internal_bandwidth() const {
  return bandwidth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::bandwidth() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.bandwidth)
  return _internal_bandwidth();
}
inline void UserStats::_internal_set_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  bandwidth_ = value;
}
inline void UserStats::set_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_bandwidth(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.bandwidth)
}

// optional uint32 onlinesecs = 16;
inline bool UserStats::_internal_has_onlinesecs() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool UserStats::has_onlinesecs() const {
  return _internal_has_onlinesecs();
}
inline void UserStats::clear_onlinesecs() {
  onlinesecs_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::_internal_onlinesecs() const {
  return onlinesecs_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::onlinesecs() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.onlinesecs)
  return _internal_onlinesecs();
}
inline void UserStats::_internal_set_onlinesecs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  onlinesecs_ = value;
}
inline void UserStats::set_onlinesecs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_onlinesecs(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.onlinesecs)
}

// optional uint32 idlesecs = 17;
inline bool UserStats::_internal_has_idlesecs() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool UserStats::has_idlesecs() const {
  return _internal_has_idlesecs();
}
inline void UserStats::clear_idlesecs() {
  idlesecs_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::_internal_idlesecs() const {
  return idlesecs_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserStats::idlesecs() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.idlesecs)
  return _internal_idlesecs();
}
inline void UserStats::_internal_set_idlesecs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  idlesecs_ = value;
}
inline void UserStats::set_idlesecs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idlesecs(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.idlesecs)
}

// optional bool strong_certificate = 18 [default = false];
inline bool UserStats::_internal_has_strong_certificate() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool UserStats::has_strong_certificate() const {
  return _internal_has_strong_certificate();
}
inline void UserStats::clear_strong_certificate() {
  strong_certificate_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool UserStats::_internal_strong_certificate() const {
  return strong_certificate_;
}
inline bool UserStats::strong_certificate() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.strong_certificate)
  return _internal_strong_certificate();
}
inline void UserStats::_internal_set_strong_certificate(bool value) {
  _has_bits_[0] |= 0x00001000u;
  strong_certificate_ = value;
}
inline void UserStats::set_strong_certificate(bool value) {
  _internal_set_strong_certificate(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.strong_certificate)
}

// optional bool opus = 19 [default = false];
inline bool UserStats::_internal_has_opus() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool UserStats::has_opus() const {
  return _internal_has_opus();
}
inline void UserStats::clear_opus() {
  opus_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool UserStats::_internal_opus() const {
  return opus_;
}
inline bool UserStats::opus() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.opus)
  return _internal_opus();
}
inline void UserStats::_internal_set_opus(bool value) {
  _has_bits_[0] |= 0x00002000u;
  opus_ = value;
}
inline void UserStats::set_opus(bool value) {
  _internal_set_opus(value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.opus)
}

// -------------------------------------------------------------------

// RequestBlob

// repeated uint32 session_texture = 1;
inline int RequestBlob::_internal_session_texture_size() const {
  return session_texture_.size();
}
inline int RequestBlob::session_texture_size() const {
  return _internal_session_texture_size();
}
inline void RequestBlob::clear_session_texture() {
  session_texture_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestBlob::_internal_session_texture(int index) const {
  return session_texture_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestBlob::session_texture(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.session_texture)
  return _internal_session_texture(index);
}
inline void RequestBlob::set_session_texture(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  session_texture_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.session_texture)
}
inline void RequestBlob::_internal_add_session_texture(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  session_texture_.Add(value);
}
inline void RequestBlob::add_session_texture(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_session_texture(value);
  // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.session_texture)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
RequestBlob::_internal_session_texture() const {
  return session_texture_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
RequestBlob::session_texture() const {
  // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.session_texture)
  return _internal_session_texture();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
RequestBlob::_internal_mutable_session_texture() {
  return &session_texture_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
RequestBlob::mutable_session_texture() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.session_texture)
  return _internal_mutable_session_texture();
}

// repeated uint32 session_comment = 2;
inline int RequestBlob::_internal_session_comment_size() const {
  return session_comment_.size();
}
inline int RequestBlob::session_comment_size() const {
  return _internal_session_comment_size();
}
inline void RequestBlob::clear_session_comment() {
  session_comment_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestBlob::_internal_session_comment(int index) const {
  return session_comment_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestBlob::session_comment(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.session_comment)
  return _internal_session_comment(index);
}
inline void RequestBlob::set_session_comment(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  session_comment_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.session_comment)
}
inline void RequestBlob::_internal_add_session_comment(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  session_comment_.Add(value);
}
inline void RequestBlob::add_session_comment(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_session_comment(value);
  // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.session_comment)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
RequestBlob::_internal_session_comment() const {
  return session_comment_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
RequestBlob::session_comment() const {
  // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.session_comment)
  return _internal_session_comment();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
RequestBlob::_internal_mutable_session_comment() {
  return &session_comment_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
RequestBlob::mutable_session_comment() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.session_comment)
  return _internal_mutable_session_comment();
}

// repeated uint32 channel_description = 3;
inline int RequestBlob::_internal_channel_description_size() const {
  return channel_description_.size();
}
inline int RequestBlob::channel_description_size() const {
  return _internal_channel_description_size();
}
inline void RequestBlob::clear_channel_description() {
  channel_description_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestBlob::_internal_channel_description(int index) const {
  return channel_description_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RequestBlob::channel_description(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.channel_description)
  return _internal_channel_description(index);
}
inline void RequestBlob::set_channel_description(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  channel_description_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.channel_description)
}
inline void RequestBlob::_internal_add_channel_description(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  channel_description_.Add(value);
}
inline void RequestBlob::add_channel_description(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_channel_description(value);
  // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.channel_description)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
RequestBlob::_internal_channel_description() const {
  return channel_description_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
RequestBlob::channel_description() const {
  // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.channel_description)
  return _internal_channel_description();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
RequestBlob::_internal_mutable_channel_description() {
  return &channel_description_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
RequestBlob::mutable_channel_description() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.channel_description)
  return _internal_mutable_channel_description();
}

// -------------------------------------------------------------------

// ServerConfig

// optional uint32 max_bandwidth = 1;
inline bool ServerConfig::_internal_has_max_bandwidth() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ServerConfig::has_max_bandwidth() const {
  return _internal_has_max_bandwidth();
}
inline void ServerConfig::clear_max_bandwidth() {
  max_bandwidth_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerConfig::_internal_max_bandwidth() const {
  return max_bandwidth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerConfig::max_bandwidth() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.max_bandwidth)
  return _internal_max_bandwidth();
}
inline void ServerConfig::_internal_set_max_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  max_bandwidth_ = value;
}
inline void ServerConfig::set_max_bandwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_bandwidth(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.max_bandwidth)
}

// optional string welcome_text = 2;
inline bool ServerConfig::_internal_has_welcome_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServerConfig::has_welcome_text() const {
  return _internal_has_welcome_text();
}
inline void ServerConfig::clear_welcome_text() {
  welcome_text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerConfig::welcome_text() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.welcome_text)
  return _internal_welcome_text();
}
inline void ServerConfig::set_welcome_text(const std::string& value) {
  _internal_set_welcome_text(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.welcome_text)
}
inline std::string* ServerConfig::mutable_welcome_text() {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ServerConfig.welcome_text)
  return _internal_mutable_welcome_text();
}
inline const std::string& ServerConfig::_internal_welcome_text() const {
  return welcome_text_.Get();
}
inline void ServerConfig::_internal_set_welcome_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServerConfig::set_welcome_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ServerConfig.welcome_text)
}
inline void ServerConfig::set_welcome_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:MumbleProto.ServerConfig.welcome_text)
}
inline void ServerConfig::set_welcome_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ServerConfig.welcome_text)
}
inline std::string* ServerConfig::_internal_mutable_welcome_text() {
  _has_bits_[0] |= 0x00000001u;
  return welcome_text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServerConfig::release_welcome_text() {
  // @@protoc_insertion_point(field_release:MumbleProto.ServerConfig.welcome_text)
  if (!_internal_has_welcome_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return welcome_text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServerConfig::set_allocated_welcome_text(std::string* welcome_text) {
  if (welcome_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  welcome_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), welcome_text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ServerConfig.welcome_text)
}

// optional bool allow_html = 3;
inline bool ServerConfig::_internal_has_allow_html() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ServerConfig::has_allow_html() const {
  return _internal_has_allow_html();
}
inline void ServerConfig::clear_allow_html() {
  allow_html_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ServerConfig::_internal_allow_html() const {
  return allow_html_;
}
inline bool ServerConfig::allow_html() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.allow_html)
  return _internal_allow_html();
}
inline void ServerConfig::_internal_set_allow_html(bool value) {
  _has_bits_[0] |= 0x00000004u;
  allow_html_ = value;
}
inline void ServerConfig::set_allow_html(bool value) {
  _internal_set_allow_html(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.allow_html)
}

// optional uint32 message_length = 4;
inline bool ServerConfig::_internal_has_message_length() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ServerConfig::has_message_length() const {
  return _internal_has_message_length();
}
inline void ServerConfig::clear_message_length() {
  message_length_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerConfig::_internal_message_length() const {
  return message_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerConfig::message_length() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.message_length)
  return _internal_message_length();
}
inline void ServerConfig::_internal_set_message_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  message_length_ = value;
}
inline void ServerConfig::set_message_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_message_length(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.message_length)
}

// optional uint32 image_message_length = 5;
inline bool ServerConfig::_internal_has_image_message_length() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ServerConfig::has_image_message_length() const {
  return _internal_has_image_message_length();
}
inline void ServerConfig::clear_image_message_length() {
  image_message_length_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerConfig::_internal_image_message_length() const {
  return image_message_length_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerConfig::image_message_length() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.image_message_length)
  return _internal_image_message_length();
}
inline void ServerConfig::_internal_set_image_message_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  image_message_length_ = value;
}
inline void ServerConfig::set_image_message_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_image_message_length(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.image_message_length)
}

// optional uint32 max_users = 6;
inline bool ServerConfig::_internal_has_max_users() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ServerConfig::has_max_users() const {
  return _internal_has_max_users();
}
inline void ServerConfig::clear_max_users() {
  max_users_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerConfig::_internal_max_users() const {
  return max_users_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerConfig::max_users() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.max_users)
  return _internal_max_users();
}
inline void ServerConfig::_internal_set_max_users(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  max_users_ = value;
}
inline void ServerConfig::set_max_users(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_users(value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.max_users)
}

// -------------------------------------------------------------------

// SuggestConfig

// optional uint32 version = 1;
inline bool SuggestConfig::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SuggestConfig::has_version() const {
  return _internal_has_version();
}
inline void SuggestConfig::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SuggestConfig::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SuggestConfig::version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.version)
  return _internal_version();
}
inline void SuggestConfig::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  version_ = value;
}
inline void SuggestConfig::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.version)
}

// optional bool positional = 2;
inline bool SuggestConfig::_internal_has_positional() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SuggestConfig::has_positional() const {
  return _internal_has_positional();
}
inline void SuggestConfig::clear_positional() {
  positional_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SuggestConfig::_internal_positional() const {
  return positional_;
}
inline bool SuggestConfig::positional() const {
  // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.positional)
  return _internal_positional();
}
inline void SuggestConfig::_internal_set_positional(bool value) {
  _has_bits_[0] |= 0x00000002u;
  positional_ = value;
}
inline void SuggestConfig::set_positional(bool value) {
  _internal_set_positional(value);
  // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.positional)
}

// optional bool push_to_talk = 3;
inline bool SuggestConfig::_internal_has_push_to_talk() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SuggestConfig::has_push_to_talk() const {
  return _internal_has_push_to_talk();
}
inline void SuggestConfig::clear_push_to_talk() {
  push_to_talk_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SuggestConfig::_internal_push_to_talk() const {
  return push_to_talk_;
}
inline bool SuggestConfig::push_to_talk() const {
  // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.push_to_talk)
  return _internal_push_to_talk();
}
inline void SuggestConfig::_internal_set_push_to_talk(bool value) {
  _has_bits_[0] |= 0x00000004u;
  push_to_talk_ = value;
}
inline void SuggestConfig::set_push_to_talk(bool value) {
  _internal_set_push_to_talk(value);
  // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.push_to_talk)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MumbleProto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MumbleProto::Reject_RejectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::Reject_RejectType>() {
  return ::MumbleProto::Reject_RejectType_descriptor();
}
template <> struct is_proto_enum< ::MumbleProto::PermissionDenied_DenyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::PermissionDenied_DenyType>() {
  return ::MumbleProto::PermissionDenied_DenyType_descriptor();
}
template <> struct is_proto_enum< ::MumbleProto::ContextActionModify_Context> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::ContextActionModify_Context>() {
  return ::MumbleProto::ContextActionModify_Context_descriptor();
}
template <> struct is_proto_enum< ::MumbleProto::ContextActionModify_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::ContextActionModify_Operation>() {
  return ::MumbleProto::ContextActionModify_Operation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Mumble_2eproto
